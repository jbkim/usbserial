
Arduino-usbdfu.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005c  00800100  00001de8  00000e7c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000de8  00001000  00001000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000021  0080015c  0080015c  00000ed8  2**0
                  ALLOC
  3 .debug_aranges 00000278  00000000  00000000  00000ed8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000078f  00000000  00000000  00001150  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003a52  00000000  00000000  000018df  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000e49  00000000  00000000  00005331  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000036cd  00000000  00000000  0000617a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000003b0  00000000  00000000  00009848  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000197b  00000000  00000000  00009bf8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001f34  00000000  00000000  0000b573  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000002c0  00000000  00000000  0000d4a7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00001000 <__vectors>:
#endif

uint8_t Endpoint_BytesToEPSizeMaskDynamic(const uint16_t Size)
{
	return Endpoint_BytesToEPSizeMask(Size);
}
    1000:	39 c0       	rjmp	.+114    	; 0x1074 <__ctors_end>
    1002:	00 00       	nop
    1004:	52 c0       	rjmp	.+164    	; 0x10aa <__bad_interrupt>
    1006:	00 00       	nop
    1008:	50 c0       	rjmp	.+160    	; 0x10aa <__bad_interrupt>
    100a:	00 00       	nop
    100c:	4e c0       	rjmp	.+156    	; 0x10aa <__bad_interrupt>
    100e:	00 00       	nop
    1010:	4c c0       	rjmp	.+152    	; 0x10aa <__bad_interrupt>
    1012:	00 00       	nop
    1014:	4a c0       	rjmp	.+148    	; 0x10aa <__bad_interrupt>
    1016:	00 00       	nop
    1018:	48 c0       	rjmp	.+144    	; 0x10aa <__bad_interrupt>
    101a:	00 00       	nop
    101c:	46 c0       	rjmp	.+140    	; 0x10aa <__bad_interrupt>
    101e:	00 00       	nop
    1020:	44 c0       	rjmp	.+136    	; 0x10aa <__bad_interrupt>
    1022:	00 00       	nop
    1024:	42 c0       	rjmp	.+132    	; 0x10aa <__bad_interrupt>
    1026:	00 00       	nop
    1028:	40 c0       	rjmp	.+128    	; 0x10aa <__bad_interrupt>
    102a:	00 00       	nop
    102c:	07 c5       	rjmp	.+2574   	; 0x1a3c <__vector_11>
    102e:	00 00       	nop
    1030:	cb c4       	rjmp	.+2454   	; 0x19c8 <__vector_12>
    1032:	00 00       	nop
    1034:	3a c0       	rjmp	.+116    	; 0x10aa <__bad_interrupt>
    1036:	00 00       	nop
    1038:	38 c0       	rjmp	.+112    	; 0x10aa <__bad_interrupt>
    103a:	00 00       	nop
    103c:	36 c0       	rjmp	.+108    	; 0x10aa <__bad_interrupt>
    103e:	00 00       	nop
    1040:	34 c0       	rjmp	.+104    	; 0x10aa <__bad_interrupt>
    1042:	00 00       	nop
    1044:	32 c0       	rjmp	.+100    	; 0x10aa <__bad_interrupt>
    1046:	00 00       	nop
    1048:	30 c0       	rjmp	.+96     	; 0x10aa <__bad_interrupt>
    104a:	00 00       	nop
    104c:	2e c0       	rjmp	.+92     	; 0x10aa <__bad_interrupt>
    104e:	00 00       	nop
    1050:	2c c0       	rjmp	.+88     	; 0x10aa <__bad_interrupt>
    1052:	00 00       	nop
    1054:	2a c0       	rjmp	.+84     	; 0x10aa <__bad_interrupt>
    1056:	00 00       	nop
    1058:	28 c0       	rjmp	.+80     	; 0x10aa <__bad_interrupt>
    105a:	00 00       	nop
    105c:	26 c0       	rjmp	.+76     	; 0x10aa <__bad_interrupt>
    105e:	00 00       	nop
    1060:	24 c0       	rjmp	.+72     	; 0x10aa <__bad_interrupt>
    1062:	00 00       	nop
    1064:	22 c0       	rjmp	.+68     	; 0x10aa <__bad_interrupt>
    1066:	00 00       	nop
    1068:	20 c0       	rjmp	.+64     	; 0x10aa <__bad_interrupt>
    106a:	00 00       	nop
    106c:	1e c0       	rjmp	.+60     	; 0x10aa <__bad_interrupt>
    106e:	00 00       	nop
    1070:	1c c0       	rjmp	.+56     	; 0x10aa <__bad_interrupt>
    1072:	00 00       	nop

00001074 <__ctors_end>:
    1074:	11 24       	eor	r1, r1
    1076:	1f be       	out	0x3f, r1	; 63
    1078:	cf ef       	ldi	r28, 0xFF	; 255
    107a:	d2 e0       	ldi	r29, 0x02	; 2
    107c:	de bf       	out	0x3e, r29	; 62
    107e:	cd bf       	out	0x3d, r28	; 61

00001080 <__do_copy_data>:
    1080:	11 e0       	ldi	r17, 0x01	; 1
    1082:	a0 e0       	ldi	r26, 0x00	; 0
    1084:	b1 e0       	ldi	r27, 0x01	; 1
    1086:	e8 ee       	ldi	r30, 0xE8	; 232
    1088:	fd e1       	ldi	r31, 0x1D	; 29
    108a:	02 c0       	rjmp	.+4      	; 0x1090 <.do_copy_data_start>

0000108c <.do_copy_data_loop>:
    108c:	05 90       	lpm	r0, Z+
    108e:	0d 92       	st	X+, r0

00001090 <.do_copy_data_start>:
    1090:	ac 35       	cpi	r26, 0x5C	; 92
    1092:	b1 07       	cpc	r27, r17
    1094:	d9 f7       	brne	.-10     	; 0x108c <.do_copy_data_loop>

00001096 <__do_clear_bss>:
    1096:	11 e0       	ldi	r17, 0x01	; 1
    1098:	ac e5       	ldi	r26, 0x5C	; 92
    109a:	b1 e0       	ldi	r27, 0x01	; 1
    109c:	01 c0       	rjmp	.+2      	; 0x10a0 <.do_clear_bss_start>

0000109e <.do_clear_bss_loop>:
    109e:	1d 92       	st	X+, r1

000010a0 <.do_clear_bss_start>:
    10a0:	ad 37       	cpi	r26, 0x7D	; 125
    10a2:	b1 07       	cpc	r27, r17
    10a4:	e1 f7       	brne	.-8      	; 0x109e <.do_clear_bss_loop>
    10a6:	55 d3       	rcall	.+1706   	; 0x1752 <main>
    10a8:	9d c6       	rjmp	.+3386   	; 0x1de4 <_exit>

000010aa <__bad_interrupt>:
    10aa:	aa cf       	rjmp	.-172    	; 0x1000 <__vectors>

000010ac <DiscardFillerBytes>:
 *  discard unused bytes in the stream from the host, including the memory program block suffix.
 *
 *  \param[in] NumberOfBytes  Number of bytes to discard from the host from the control endpoint
 */
static void DiscardFillerBytes(uint8_t NumberOfBytes)
{
    10ac:	98 2f       	mov	r25, r24
    10ae:	15 c0       	rjmp	.+42     	; 0x10da <DiscardFillerBytes+0x2e>
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
    10b0:	80 91 f2 00 	lds	r24, 0x00F2
	while (NumberOfBytes--)
	{
		if (!(Endpoint_BytesInEndpoint()))
    10b4:	88 23       	and	r24, r24
    10b6:	71 f4       	brne	.+28     	; 0x10d4 <DiscardFillerBytes+0x28>
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << RXOUTI);	
    10b8:	80 91 e8 00 	lds	r24, 0x00E8
    10bc:	8b 7f       	andi	r24, 0xFB	; 251
    10be:	80 93 e8 00 	sts	0x00E8, r24
    10c2:	03 c0       	rjmp	.+6      	; 0x10ca <DiscardFillerBytes+0x1e>
			Endpoint_ClearOUT();

			/* Wait until next data packet received */
			while (!(Endpoint_IsOUTReceived()))
			{				
				if (USB_DeviceState == DEVICE_STATE_Unattached)
    10c4:	8e b3       	in	r24, 0x1e	; 30
    10c6:	88 23       	and	r24, r24
    10c8:	51 f0       	breq	.+20     	; 0x10de <DiscardFillerBytes+0x32>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    10ca:	80 91 e8 00 	lds	r24, 0x00E8
		if (!(Endpoint_BytesInEndpoint()))
		{
			Endpoint_ClearOUT();

			/* Wait until next data packet received */
			while (!(Endpoint_IsOUTReceived()))
    10ce:	82 ff       	sbrs	r24, 2
    10d0:	f9 cf       	rjmp	.-14     	; 0x10c4 <DiscardFillerBytes+0x18>
    10d2:	02 c0       	rjmp	.+4      	; 0x10d8 <DiscardFillerBytes+0x2c>
			static inline void Endpoint_Discard_Byte(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Discard_Byte(void)
			{
				uint8_t Dummy;
				
				Dummy = UEDATX;
    10d4:	80 91 f1 00 	lds	r24, 0x00F1
    10d8:	91 50       	subi	r25, 0x01	; 1
 *
 *  \param[in] NumberOfBytes  Number of bytes to discard from the host from the control endpoint
 */
static void DiscardFillerBytes(uint8_t NumberOfBytes)
{
	while (NumberOfBytes--)
    10da:	99 23       	and	r25, r25
    10dc:	49 f7       	brne	.-46     	; 0x10b0 <DiscardFillerBytes+0x4>
    10de:	08 95       	ret

000010e0 <LoadStartEndAddresses>:
	union
	{
		uint8_t  Bytes[2];
		uint16_t Word;
	} Address[2] = {{.Bytes = {SentCommand.Data[2], SentCommand.Data[1]}},
	                {.Bytes = {SentCommand.Data[4], SentCommand.Data[3]}}};
    10e0:	20 91 6a 01 	lds	r18, 0x016A
    10e4:	30 91 69 01 	lds	r19, 0x0169
		
	/* Load in the start and ending read addresses from the sent data packet */
	StartAddr = Address[0].Word;
    10e8:	80 91 68 01 	lds	r24, 0x0168
    10ec:	90 91 67 01 	lds	r25, 0x0167
    10f0:	80 93 61 01 	sts	0x0161, r24
    10f4:	90 93 62 01 	sts	0x0162, r25
	EndAddr   = Address[1].Word;
    10f8:	c9 01       	movw	r24, r18
    10fa:	80 93 63 01 	sts	0x0163, r24
    10fe:	90 93 64 01 	sts	0x0164, r25
}
    1102:	08 95       	ret

00001104 <ProcessBootloaderCommand>:
// 			return;
// 		}
// 	}

	/* Dispatch the required command processing routine based on the command type */
	switch (SentCommand.Command)
    1104:	80 91 65 01 	lds	r24, 0x0165
    1108:	84 30       	cpi	r24, 0x04	; 4
    110a:	09 f4       	brne	.+2      	; 0x110e <ProcessBootloaderCommand+0xa>
    110c:	5a c0       	rjmp	.+180    	; 0x11c2 <ProcessBootloaderCommand+0xbe>
    110e:	85 30       	cpi	r24, 0x05	; 5
    1110:	30 f4       	brcc	.+12     	; 0x111e <ProcessBootloaderCommand+0x1a>
    1112:	81 30       	cpi	r24, 0x01	; 1
    1114:	59 f0       	breq	.+22     	; 0x112c <ProcessBootloaderCommand+0x28>
    1116:	83 30       	cpi	r24, 0x03	; 3
    1118:	09 f0       	breq	.+2      	; 0x111c <ProcessBootloaderCommand+0x18>
    111a:	c3 c0       	rjmp	.+390    	; 0x12a2 <ProcessBootloaderCommand+0x19e>
    111c:	1f c0       	rjmp	.+62     	; 0x115c <ProcessBootloaderCommand+0x58>
    111e:	85 30       	cpi	r24, 0x05	; 5
    1120:	09 f4       	brne	.+2      	; 0x1124 <ProcessBootloaderCommand+0x20>
    1122:	a0 c0       	rjmp	.+320    	; 0x1264 <ProcessBootloaderCommand+0x160>
    1124:	86 30       	cpi	r24, 0x06	; 6
    1126:	09 f0       	breq	.+2      	; 0x112a <ProcessBootloaderCommand+0x26>
    1128:	bc c0       	rjmp	.+376    	; 0x12a2 <ProcessBootloaderCommand+0x19e>
    112a:	af c0       	rjmp	.+350    	; 0x128a <ProcessBootloaderCommand+0x186>
/** Handler for a Memory Program command issued by the host. This routine handles the preparations needed
 *  to write subsequent data from the host into the specified memory.
 */
static void ProcessMemProgCommand(void)
{
	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00) ||                          // Write FLASH command
    112c:	80 91 66 01 	lds	r24, 0x0166
    1130:	82 30       	cpi	r24, 0x02	; 2
    1132:	08 f0       	brcs	.+2      	; 0x1136 <ProcessBootloaderCommand+0x32>
    1134:	b6 c0       	rjmp	.+364    	; 0x12a2 <ProcessBootloaderCommand+0x19e>
	    IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                            // Write EEPROM command
	{
		/* Load in the start and ending read addresses */
		LoadStartEndAddresses();
    1136:	d4 df       	rcall	.-88     	; 0x10e0 <LoadStartEndAddresses>
		
		/* If FLASH is being written to, we need to pre-erase the first page to write to */
		if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))
    1138:	80 91 66 01 	lds	r24, 0x0166
    113c:	88 23       	and	r24, r24
    113e:	61 f4       	brne	.+24     	; 0x1158 <ProcessBootloaderCommand+0x54>
		{
			union
			{
				uint16_t Words[2];
				uint32_t Long;
			} CurrFlashAddress = {.Words = {StartAddr, Flash64KBPage}};
    1140:	80 91 61 01 	lds	r24, 0x0161
    1144:	90 91 62 01 	lds	r25, 0x0162
			
			/* Erase the current page's temp buffer */
			boot_page_erase(CurrFlashAddress.Long);
    1148:	23 e0       	ldi	r18, 0x03	; 3
    114a:	fc 01       	movw	r30, r24
    114c:	20 93 57 00 	sts	0x0057, r18
    1150:	e8 95       	spm
			boot_spm_busy_wait();
    1152:	07 b6       	in	r0, 0x37	; 55
    1154:	00 fc       	sbrc	r0, 0
    1156:	fd cf       	rjmp	.-6      	; 0x1152 <ProcessBootloaderCommand+0x4e>
		}
		
		/* Set the state so that the next DNLOAD requests reads in the firmware */
		DFU_State = dfuDNLOAD_IDLE;
    1158:	85 e0       	ldi	r24, 0x05	; 5
    115a:	08 c0       	rjmp	.+16     	; 0x116c <ProcessBootloaderCommand+0x68>
 *  to read subsequent data from the specified memory out to the host, as well as implementing the memory
 *  blank check command.
 */
static void ProcessMemReadCommand(void)
{
	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00) ||                          // Read FLASH command
    115c:	80 91 66 01 	lds	r24, 0x0166
    1160:	88 23       	and	r24, r24
    1162:	11 f0       	breq	.+4      	; 0x1168 <ProcessBootloaderCommand+0x64>
    1164:	82 30       	cpi	r24, 0x02	; 2
    1166:	29 f4       	brne	.+10     	; 0x1172 <ProcessBootloaderCommand+0x6e>
        IS_ONEBYTE_COMMAND(SentCommand.Data, 0x02))                            // Read EEPROM command
	{
		/* Load in the start and ending read addresses */
		LoadStartEndAddresses();
    1168:	bb df       	rcall	.-138    	; 0x10e0 <LoadStartEndAddresses>

		/* Set the state so that the next UPLOAD requests read out the firmware */
		DFU_State = dfuUPLOAD_IDLE;
    116a:	89 e0       	ldi	r24, 0x09	; 9
    116c:	80 93 01 01 	sts	0x0101, r24
    1170:	08 95       	ret
	}
	else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                       // Blank check FLASH command
    1172:	81 30       	cpi	r24, 0x01	; 1
    1174:	09 f0       	breq	.+2      	; 0x1178 <ProcessBootloaderCommand+0x74>
    1176:	95 c0       	rjmp	.+298    	; 0x12a2 <ProcessBootloaderCommand+0x19e>
    1178:	20 e0       	ldi	r18, 0x00	; 0
    117a:	30 e0       	ldi	r19, 0x00	; 0
    117c:	40 e0       	ldi	r20, 0x00	; 0
    117e:	50 e0       	ldi	r21, 0x00	; 0
		{
			/* Check if the current byte is not blank */
			#if (FLASHEND > 0xFFFF)
			if (pgm_read_byte_far(CurrFlashAddress) != 0xFF)
			#else
			if (pgm_read_byte(CurrFlashAddress) != 0xFF)
    1180:	f9 01       	movw	r30, r18
    1182:	84 91       	lpm	r24, Z+
    1184:	8f 3f       	cpi	r24, 0xFF	; 255
    1186:	81 f0       	breq	.+32     	; 0x11a8 <ProcessBootloaderCommand+0xa4>
			#endif
			{
				/* Save the location of the first non-blank byte for response back to the host */
				Flash64KBPage = (CurrFlashAddress >> 16);
    1188:	ca 01       	movw	r24, r20
    118a:	aa 27       	eor	r26, r26
    118c:	bb 27       	eor	r27, r27
    118e:	80 93 60 01 	sts	0x0160, r24
				StartAddr     = CurrFlashAddress;
    1192:	30 93 62 01 	sts	0x0162, r19
    1196:	20 93 61 01 	sts	0x0161, r18
			
				/* Set state and status variables to the appropriate error values */
				DFU_State  = dfuERROR;
    119a:	8a e0       	ldi	r24, 0x0A	; 10
    119c:	80 93 01 01 	sts	0x0101, r24
				DFU_Status = errCHECK_ERASED;
    11a0:	85 e0       	ldi	r24, 0x05	; 5
    11a2:	80 93 5d 01 	sts	0x015D, r24
    11a6:	08 95       	ret

				break;
			}

			CurrFlashAddress++;
    11a8:	2f 5f       	subi	r18, 0xFF	; 255
    11aa:	3f 4f       	sbci	r19, 0xFF	; 255
    11ac:	4f 4f       	sbci	r20, 0xFF	; 255
    11ae:	5f 4f       	sbci	r21, 0xFF	; 255
	}
	else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                       // Blank check FLASH command
	{
		uint32_t CurrFlashAddress = 0;

		while (CurrFlashAddress < BOOT_START_ADDR)
    11b0:	20 30       	cpi	r18, 0x00	; 0
    11b2:	f0 e1       	ldi	r31, 0x10	; 16
    11b4:	3f 07       	cpc	r19, r31
    11b6:	f0 e0       	ldi	r31, 0x00	; 0
    11b8:	4f 07       	cpc	r20, r31
    11ba:	f0 e0       	ldi	r31, 0x00	; 0
    11bc:	5f 07       	cpc	r21, r31
    11be:	01 f7       	brne	.-64     	; 0x1180 <ProcessBootloaderCommand+0x7c>
    11c0:	08 95       	ret
/** Handler for a Data Write command issued by the host. This routine handles non-programming commands such as
 *  bootloader exit (both via software jumps and hardware watchdog resets) and flash memory erasure.
 */
static void ProcessWriteCommand(void)
{
	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x03))                            // Start application
    11c2:	80 91 66 01 	lds	r24, 0x0166
    11c6:	83 30       	cpi	r24, 0x03	; 3
    11c8:	51 f5       	brne	.+84     	; 0x121e <ProcessBootloaderCommand+0x11a>
	{
		/* Indicate that the bootloader is terminating */
		WaitForExit = true;
    11ca:	81 e0       	ldi	r24, 0x01	; 1
    11cc:	80 93 5c 01 	sts	0x015C, r24

		/* Check if data supplied for the Start Program command - no data executes the program */
		if (SentCommand.DataSize)
    11d0:	80 91 6b 01 	lds	r24, 0x016B
    11d4:	90 91 6c 01 	lds	r25, 0x016C
    11d8:	89 2b       	or	r24, r25
    11da:	71 f0       	breq	.+28     	; 0x11f8 <ProcessBootloaderCommand+0xf4>
		{
			if (SentCommand.Data[1] == 0x01)                                   // Start via jump
    11dc:	80 91 67 01 	lds	r24, 0x0167
    11e0:	81 30       	cpi	r24, 0x01	; 1
    11e2:	09 f0       	breq	.+2      	; 0x11e6 <ProcessBootloaderCommand+0xe2>
    11e4:	5e c0       	rjmp	.+188    	; 0x12a2 <ProcessBootloaderCommand+0x19e>
			{
				union
				{
					uint8_t  Bytes[2];
					AppPtr_t FuncPtr;
				} Address = {.Bytes = {SentCommand.Data[4], SentCommand.Data[3]}};
    11e6:	80 91 6a 01 	lds	r24, 0x016A
    11ea:	90 91 69 01 	lds	r25, 0x0169

				/* Load in the jump address into the application start address pointer */
				AppStartPtr = Address.FuncPtr;
    11ee:	90 93 5f 01 	sts	0x015F, r25
    11f2:	80 93 5e 01 	sts	0x015E, r24
    11f6:	08 95       	ret
			}
		}
		else
		{
			if (SentCommand.Data[1] == 0x00)                                   // Start via watchdog
    11f8:	80 91 67 01 	lds	r24, 0x0167
    11fc:	88 23       	and	r24, r24
    11fe:	61 f4       	brne	.+24     	; 0x1218 <ProcessBootloaderCommand+0x114>
			{
				/* Start the watchdog to reset the AVR once the communications are finalized */
				wdt_enable(WDTO_250MS);
    1200:	2c e0       	ldi	r18, 0x0C	; 12
    1202:	88 e1       	ldi	r24, 0x18	; 24
    1204:	90 e0       	ldi	r25, 0x00	; 0
    1206:	0f b6       	in	r0, 0x3f	; 63
    1208:	f8 94       	cli
    120a:	a8 95       	wdr
    120c:	80 93 60 00 	sts	0x0060, r24
    1210:	0f be       	out	0x3f, r0	; 63
    1212:	20 93 60 00 	sts	0x0060, r18
    1216:	08 95       	ret
			}
			else                                                               // Start via jump
			{
				/* Set the flag to terminate the bootloader at next opportunity */
				RunBootloader = false;
    1218:	10 92 00 01 	sts	0x0100, r1
    121c:	08 95       	ret
			}
		}
	}
	else if (IS_TWOBYTE_COMMAND(SentCommand.Data, 0x00, 0xFF))                 // Erase flash
    121e:	88 23       	and	r24, r24
    1220:	09 f0       	breq	.+2      	; 0x1224 <ProcessBootloaderCommand+0x120>
    1222:	3f c0       	rjmp	.+126    	; 0x12a2 <ProcessBootloaderCommand+0x19e>
    1224:	80 91 67 01 	lds	r24, 0x0167
    1228:	8f 3f       	cpi	r24, 0xFF	; 255
    122a:	09 f0       	breq	.+2      	; 0x122e <ProcessBootloaderCommand+0x12a>
    122c:	3a c0       	rjmp	.+116    	; 0x12a2 <ProcessBootloaderCommand+0x19e>
    122e:	e0 e0       	ldi	r30, 0x00	; 0
    1230:	f0 e0       	ldi	r31, 0x00	; 0
		uint32_t CurrFlashAddress = 0;

		/* Clear the application section of flash */
		while (CurrFlashAddress < BOOT_START_ADDR)
		{
			boot_page_erase(CurrFlashAddress);
    1232:	93 e0       	ldi	r25, 0x03	; 3
			boot_spm_busy_wait();
			boot_page_write(CurrFlashAddress);
    1234:	85 e0       	ldi	r24, 0x05	; 5
		uint32_t CurrFlashAddress = 0;

		/* Clear the application section of flash */
		while (CurrFlashAddress < BOOT_START_ADDR)
		{
			boot_page_erase(CurrFlashAddress);
    1236:	90 93 57 00 	sts	0x0057, r25
    123a:	e8 95       	spm
			boot_spm_busy_wait();
    123c:	07 b6       	in	r0, 0x37	; 55
    123e:	00 fc       	sbrc	r0, 0
    1240:	fd cf       	rjmp	.-6      	; 0x123c <ProcessBootloaderCommand+0x138>
			boot_page_write(CurrFlashAddress);
    1242:	80 93 57 00 	sts	0x0057, r24
    1246:	e8 95       	spm
			boot_spm_busy_wait();
    1248:	07 b6       	in	r0, 0x37	; 55
    124a:	00 fc       	sbrc	r0, 0
    124c:	fd cf       	rjmp	.-6      	; 0x1248 <ProcessBootloaderCommand+0x144>
    124e:	e0 58       	subi	r30, 0x80	; 128
    1250:	ff 4f       	sbci	r31, 0xFF	; 255
	else if (IS_TWOBYTE_COMMAND(SentCommand.Data, 0x00, 0xFF))                 // Erase flash
	{
		uint32_t CurrFlashAddress = 0;

		/* Clear the application section of flash */
		while (CurrFlashAddress < BOOT_START_ADDR)
    1252:	20 e1       	ldi	r18, 0x10	; 16
    1254:	e0 30       	cpi	r30, 0x00	; 0
    1256:	f2 07       	cpc	r31, r18
    1258:	71 f7       	brne	.-36     	; 0x1236 <ProcessBootloaderCommand+0x132>

			CurrFlashAddress += SPM_PAGESIZE;
		}

		/* Re-enable the RWW section of flash as writing to the flash locks it out */
		boot_rww_enable();
    125a:	81 e1       	ldi	r24, 0x11	; 17
    125c:	80 93 57 00 	sts	0x0057, r24
    1260:	e8 95       	spm
    1262:	08 95       	ret
static void ProcessReadCommand(void)
{
	const uint8_t BootloaderInfo[3] = {BOOTLOADER_VERSION, BOOTLOADER_ID_BYTE1, BOOTLOADER_ID_BYTE2};
	const uint8_t SignatureInfo[3]  = {AVR_SIGNATURE_1,    AVR_SIGNATURE_2,     AVR_SIGNATURE_3};

	uint8_t DataIndexToRead = SentCommand.Data[1];
    1264:	e0 91 67 01 	lds	r30, 0x0167

	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))                         // Read bootloader info
    1268:	80 91 66 01 	lds	r24, 0x0166
    126c:	88 23       	and	r24, r24
    126e:	21 f4       	brne	.+8      	; 0x1278 <ProcessBootloaderCommand+0x174>
	  ResponseByte = BootloaderInfo[DataIndexToRead];
    1270:	f0 e0       	ldi	r31, 0x00	; 0
    1272:	eb 5f       	subi	r30, 0xFB	; 251
    1274:	fe 4f       	sbci	r31, 0xFE	; 254
    1276:	05 c0       	rjmp	.+10     	; 0x1282 <ProcessBootloaderCommand+0x17e>
	else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                    // Read signature byte
    1278:	81 30       	cpi	r24, 0x01	; 1
    127a:	99 f4       	brne	.+38     	; 0x12a2 <ProcessBootloaderCommand+0x19e>
	  ResponseByte = SignatureInfo[DataIndexToRead - 0x30];
    127c:	f0 e0       	ldi	r31, 0x00	; 0
    127e:	ee 52       	subi	r30, 0x2E	; 46
    1280:	ff 4f       	sbci	r31, 0xFF	; 255
    1282:	80 81       	ld	r24, Z
    1284:	80 93 70 01 	sts	0x0170, r24
    1288:	08 95       	ret
			break;
		case COMMAND_READ:
			ProcessReadCommand();
			break;
		case COMMAND_CHANGE_BASE_ADDR:
			if (IS_TWOBYTE_COMMAND(SentCommand.Data, 0x03, 0x00))              // Set 64KB flash page command
    128a:	80 91 66 01 	lds	r24, 0x0166
    128e:	83 30       	cpi	r24, 0x03	; 3
    1290:	41 f4       	brne	.+16     	; 0x12a2 <ProcessBootloaderCommand+0x19e>
    1292:	80 91 67 01 	lds	r24, 0x0167
    1296:	88 23       	and	r24, r24
    1298:	21 f4       	brne	.+8      	; 0x12a2 <ProcessBootloaderCommand+0x19e>
			  Flash64KBPage = SentCommand.Data[2];
    129a:	80 91 68 01 	lds	r24, 0x0168
    129e:	80 93 60 01 	sts	0x0160, r24
    12a2:	08 95       	ret

000012a4 <EVENT_USB_Device_UnhandledControlRequest>:
/** Event handler for the USB_UnhandledControlRequest event. This is used to catch standard and class specific
 *  control requests that are not handled internally by the USB library (including the DFU commands, which are
 *  all issued via the control endpoint), so that they can be handled appropriately for the application.
 */
void EVENT_USB_Device_UnhandledControlRequest(void)
{
    12a4:	2f 92       	push	r2
    12a6:	3f 92       	push	r3
    12a8:	4f 92       	push	r4
    12aa:	5f 92       	push	r5
    12ac:	6f 92       	push	r6
    12ae:	7f 92       	push	r7
    12b0:	9f 92       	push	r9
    12b2:	af 92       	push	r10
    12b4:	bf 92       	push	r11
    12b6:	cf 92       	push	r12
    12b8:	df 92       	push	r13
    12ba:	ef 92       	push	r14
    12bc:	ff 92       	push	r15
    12be:	0f 93       	push	r16
    12c0:	1f 93       	push	r17
    12c2:	cf 93       	push	r28
    12c4:	df 93       	push	r29
	/* Get the size of the command and data from the wLength value */
	SentCommand.DataSize = USB_ControlRequest.wLength;
    12c6:	80 91 7b 01 	lds	r24, 0x017B
    12ca:	90 91 7c 01 	lds	r25, 0x017C
    12ce:	90 93 6c 01 	sts	0x016C, r25
    12d2:	80 93 6b 01 	sts	0x016B, r24

	/* Turn off TX LED(s) once the TX pulse period has elapsed */
	if (PulseMSRemaining.TxLEDPulse && !(--PulseMSRemaining.TxLEDPulse))
    12d6:	80 91 6d 01 	lds	r24, 0x016D
    12da:	88 23       	and	r24, r24
    12dc:	51 f0       	breq	.+20     	; 0x12f2 <EVENT_USB_Device_UnhandledControlRequest+0x4e>
    12de:	80 91 6d 01 	lds	r24, 0x016D
    12e2:	81 50       	subi	r24, 0x01	; 1
    12e4:	80 93 6d 01 	sts	0x016D, r24
    12e8:	80 91 6d 01 	lds	r24, 0x016D
    12ec:	88 23       	and	r24, r24
    12ee:	09 f4       	brne	.+2      	; 0x12f2 <EVENT_USB_Device_UnhandledControlRequest+0x4e>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_TurnOffLEDs(const uint8_t LEDMask)
			{
				PORTD |= LEDMask;
    12f0:	5d 9a       	sbi	0x0b, 5	; 11
		LEDs_TurnOffLEDs(LEDMASK_TX);
		
	/* Turn off RX LED(s) once the RX pulse period has elapsed */
	if (PulseMSRemaining.RxLEDPulse && !(--PulseMSRemaining.RxLEDPulse))
    12f2:	80 91 6e 01 	lds	r24, 0x016E
    12f6:	88 23       	and	r24, r24
    12f8:	51 f0       	breq	.+20     	; 0x130e <EVENT_USB_Device_UnhandledControlRequest+0x6a>
    12fa:	80 91 6e 01 	lds	r24, 0x016E
    12fe:	81 50       	subi	r24, 0x01	; 1
    1300:	80 93 6e 01 	sts	0x016E, r24
    1304:	80 91 6e 01 	lds	r24, 0x016E
    1308:	88 23       	and	r24, r24
    130a:	09 f4       	brne	.+2      	; 0x130e <EVENT_USB_Device_UnhandledControlRequest+0x6a>
    130c:	5c 9a       	sbi	0x0b, 4	; 11
		LEDs_TurnOffLEDs(LEDMASK_RX);

	switch (USB_ControlRequest.bRequest)
    130e:	80 91 76 01 	lds	r24, 0x0176
    1312:	83 30       	cpi	r24, 0x03	; 3
    1314:	09 f4       	brne	.+2      	; 0x1318 <EVENT_USB_Device_UnhandledControlRequest+0x74>
    1316:	b8 c1       	rjmp	.+880    	; 0x1688 <EVENT_USB_Device_UnhandledControlRequest+0x3e4>
    1318:	84 30       	cpi	r24, 0x04	; 4
    131a:	30 f4       	brcc	.+12     	; 0x1328 <EVENT_USB_Device_UnhandledControlRequest+0x84>
    131c:	81 30       	cpi	r24, 0x01	; 1
    131e:	71 f0       	breq	.+28     	; 0x133c <EVENT_USB_Device_UnhandledControlRequest+0x98>
    1320:	82 30       	cpi	r24, 0x02	; 2
    1322:	09 f0       	breq	.+2      	; 0x1326 <EVENT_USB_Device_UnhandledControlRequest+0x82>
    1324:	e9 c1       	rjmp	.+978    	; 0x16f8 <EVENT_USB_Device_UnhandledControlRequest+0x454>
    1326:	14 c1       	rjmp	.+552    	; 0x1550 <EVENT_USB_Device_UnhandledControlRequest+0x2ac>
    1328:	85 30       	cpi	r24, 0x05	; 5
    132a:	09 f4       	brne	.+2      	; 0x132e <EVENT_USB_Device_UnhandledControlRequest+0x8a>
    132c:	cb c1       	rjmp	.+918    	; 0x16c4 <EVENT_USB_Device_UnhandledControlRequest+0x420>
    132e:	85 30       	cpi	r24, 0x05	; 5
    1330:	08 f4       	brcc	.+2      	; 0x1334 <EVENT_USB_Device_UnhandledControlRequest+0x90>
    1332:	c0 c1       	rjmp	.+896    	; 0x16b4 <EVENT_USB_Device_UnhandledControlRequest+0x410>
    1334:	86 30       	cpi	r24, 0x06	; 6
    1336:	09 f0       	breq	.+2      	; 0x133a <EVENT_USB_Device_UnhandledControlRequest+0x96>
    1338:	df c1       	rjmp	.+958    	; 0x16f8 <EVENT_USB_Device_UnhandledControlRequest+0x454>
    133a:	d3 c1       	rjmp	.+934    	; 0x16e2 <EVENT_USB_Device_UnhandledControlRequest+0x43e>
				PORTD |= LEDS_ALL_LEDS;
			}
			
			static inline void LEDs_TurnOnLEDs(const uint8_t LEDMask)
			{
				PORTD &= ~LEDMask;
    133c:	5c 98       	cbi	0x0b, 4	; 11
	{
		case DFU_DNLOAD:
			LEDs_TurnOnLEDs(LEDMASK_RX);
			PulseMSRemaining.RxLEDPulse = TX_RX_LED_PULSE_MS;		
    133e:	83 e0       	ldi	r24, 0x03	; 3
    1340:	80 93 6e 01 	sts	0x016E, r24
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1344:	80 91 e8 00 	lds	r24, 0x00E8
    1348:	87 7f       	andi	r24, 0xF7	; 247
    134a:	80 93 e8 00 	sts	0x00E8, r24
		
			Endpoint_ClearSETUP();
			
			/* Check if bootloader is waiting to terminate */
			if (WaitForExit)
    134e:	80 91 5c 01 	lds	r24, 0x015C
    1352:	88 23       	and	r24, r24
    1354:	29 f0       	breq	.+10     	; 0x1360 <EVENT_USB_Device_UnhandledControlRequest+0xbc>
			{
				/* Bootloader is terminating - process last received command */
				ProcessBootloaderCommand();
    1356:	d6 de       	rcall	.-596    	; 0x1104 <ProcessBootloaderCommand>
			}

			static inline void LEDs_TurnOffLEDs(const uint8_t LEDMask)
			{
				PORTD |= LEDMask;
    1358:	5d 9a       	sbi	0x0b, 5	; 11
				/* Turn off TX/RX status LEDs so that they're not left on when application starts */
				LEDs_TurnOffLEDs(LEDMASK_TX);
				LEDs_TurnOffLEDs(LEDMASK_RX);
				
				/* Indicate that the last command has now been processed - free to exit bootloader */
				WaitForExit = false;
    135a:	5c 9a       	sbi	0x0b, 4	; 11
    135c:	10 92 5c 01 	sts	0x015C, r1
			}
			  
			/* If the request has a data stage, load it into the command struct */
			if (SentCommand.DataSize)
    1360:	20 91 6b 01 	lds	r18, 0x016B
    1364:	30 91 6c 01 	lds	r19, 0x016C
    1368:	21 15       	cp	r18, r1
    136a:	31 05       	cpc	r19, r1
    136c:	29 f4       	brne	.+10     	; 0x1378 <EVENT_USB_Device_UnhandledControlRequest+0xd4>
    136e:	2a c0       	rjmp	.+84     	; 0x13c4 <EVENT_USB_Device_UnhandledControlRequest+0x120>
			{
				while (!(Endpoint_IsOUTReceived()))
				{				
					if (USB_DeviceState == DEVICE_STATE_Unattached)
    1370:	8e b3       	in	r24, 0x1e	; 30
    1372:	88 23       	and	r24, r24
    1374:	09 f4       	brne	.+2      	; 0x1378 <EVENT_USB_Device_UnhandledControlRequest+0xd4>
    1376:	c0 c1       	rjmp	.+896    	; 0x16f8 <EVENT_USB_Device_UnhandledControlRequest+0x454>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1378:	80 91 e8 00 	lds	r24, 0x00E8
			}
			  
			/* If the request has a data stage, load it into the command struct */
			if (SentCommand.DataSize)
			{
				while (!(Endpoint_IsOUTReceived()))
    137c:	82 ff       	sbrs	r24, 2
    137e:	f8 cf       	rjmp	.-16     	; 0x1370 <EVENT_USB_Device_UnhandledControlRequest+0xcc>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    1380:	80 91 f1 00 	lds	r24, 0x00F1
					if (USB_DeviceState == DEVICE_STATE_Unattached)
					  return;
				}

				/* First byte of the data stage is the DNLOAD request's command */
				SentCommand.Command = Endpoint_Read_Byte();
    1384:	80 93 65 01 	sts	0x0165, r24
					
				/* One byte of the data stage is the command, so subtract it from the total data bytes */
				SentCommand.DataSize--;
    1388:	21 50       	subi	r18, 0x01	; 1
    138a:	30 40       	sbci	r19, 0x00	; 0
    138c:	30 93 6c 01 	sts	0x016C, r19
    1390:	20 93 6b 01 	sts	0x016B, r18
    1394:	e6 e6       	ldi	r30, 0x66	; 102
    1396:	f1 e0       	ldi	r31, 0x01	; 1
    1398:	0c c0       	rjmp	.+24     	; 0x13b2 <EVENT_USB_Device_UnhandledControlRequest+0x10e>
    139a:	80 91 f1 00 	lds	r24, 0x00F1
				
				/* Load in the rest of the data stage as command parameters */
				for (uint8_t DataByte = 0; (DataByte < sizeof(SentCommand.Data)) &&
				     Endpoint_BytesInEndpoint(); DataByte++)
				{
					SentCommand.Data[DataByte] = Endpoint_Read_Byte();
    139e:	81 93       	st	Z+, r24
    13a0:	21 50       	subi	r18, 0x01	; 1
    13a2:	30 40       	sbci	r19, 0x00	; 0
					
				/* One byte of the data stage is the command, so subtract it from the total data bytes */
				SentCommand.DataSize--;
				
				/* Load in the rest of the data stage as command parameters */
				for (uint8_t DataByte = 0; (DataByte < sizeof(SentCommand.Data)) &&
    13a4:	81 e0       	ldi	r24, 0x01	; 1
    13a6:	eb 36       	cpi	r30, 0x6B	; 107
    13a8:	f8 07       	cpc	r31, r24
    13aa:	19 f4       	brne	.+6      	; 0x13b2 <EVENT_USB_Device_UnhandledControlRequest+0x10e>
    13ac:	31 83       	std	Z+1, r19	; 0x01
    13ae:	20 83       	st	Z, r18
    13b0:	08 c0       	rjmp	.+16     	; 0x13c2 <EVENT_USB_Device_UnhandledControlRequest+0x11e>
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
    13b2:	80 91 f2 00 	lds	r24, 0x00F2
    13b6:	88 23       	and	r24, r24
    13b8:	81 f7       	brne	.-32     	; 0x139a <EVENT_USB_Device_UnhandledControlRequest+0xf6>
    13ba:	30 93 6c 01 	sts	0x016C, r19
    13be:	20 93 6b 01 	sts	0x016B, r18
					SentCommand.Data[DataByte] = Endpoint_Read_Byte();
					SentCommand.DataSize--;
				}
				
				/* Process the command */
				ProcessBootloaderCommand();
    13c2:	a0 de       	rcall	.-704    	; 0x1104 <ProcessBootloaderCommand>
			}
			
			/* Check if currently downloading firmware */
			if (DFU_State == dfuDNLOAD_IDLE)
    13c4:	80 91 01 01 	lds	r24, 0x0101
    13c8:	85 30       	cpi	r24, 0x05	; 5
    13ca:	09 f0       	breq	.+2      	; 0x13ce <EVENT_USB_Device_UnhandledControlRequest+0x12a>
    13cc:	bd c0       	rjmp	.+378    	; 0x1548 <EVENT_USB_Device_UnhandledControlRequest+0x2a4>
			{									
				if (!(SentCommand.DataSize))
    13ce:	80 91 6b 01 	lds	r24, 0x016B
    13d2:	90 91 6c 01 	lds	r25, 0x016C
    13d6:	89 2b       	or	r24, r25
    13d8:	21 f4       	brne	.+8      	; 0x13e2 <EVENT_USB_Device_UnhandledControlRequest+0x13e>
				{
					DFU_State = dfuIDLE;
    13da:	82 e0       	ldi	r24, 0x02	; 2
    13dc:	80 93 01 01 	sts	0x0101, r24
    13e0:	b3 c0       	rjmp	.+358    	; 0x1548 <EVENT_USB_Device_UnhandledControlRequest+0x2a4>
				}
				else
				{
					/* Throw away the filler bytes before the start of the firmware */
					DiscardFillerBytes(DFU_FILLER_BYTES_SIZE);
    13e2:	8a e1       	ldi	r24, 0x1A	; 26
    13e4:	63 de       	rcall	.-826    	; 0x10ac <DiscardFillerBytes>

					/* Throw away the packet alignment filler bytes before the start of the firmware */
					DiscardFillerBytes(StartAddr % FIXED_CONTROL_ENDPOINT_SIZE);
    13e6:	80 91 61 01 	lds	r24, 0x0161
    13ea:	8f 71       	andi	r24, 0x1F	; 31
    13ec:	5f de       	rcall	.-834    	; 0x10ac <DiscardFillerBytes>
					
					/* Calculate the number of bytes remaining to be written */
					uint16_t BytesRemaining = ((EndAddr - StartAddr) + 1);
    13ee:	c0 91 63 01 	lds	r28, 0x0163
    13f2:	d0 91 64 01 	lds	r29, 0x0164
    13f6:	20 91 61 01 	lds	r18, 0x0161
    13fa:	30 91 62 01 	lds	r19, 0x0162
    13fe:	21 96       	adiw	r28, 0x01	; 1
    1400:	ae 01       	movw	r20, r28
    1402:	42 1b       	sub	r20, r18
    1404:	53 0b       	sbc	r21, r19
    1406:	21 97       	sbiw	r28, 0x01	; 1
					
					if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))        // Write flash
    1408:	80 91 66 01 	lds	r24, 0x0166
    140c:	88 23       	and	r24, r24
    140e:	09 f0       	breq	.+2      	; 0x1412 <EVENT_USB_Device_UnhandledControlRequest+0x16e>
    1410:	92 c0       	rjmp	.+292    	; 0x1536 <EVENT_USB_Device_UnhandledControlRequest+0x292>
					{
						/* Calculate the number of words to be written from the number of bytes to be written */
						uint16_t WordsRemaining = (BytesRemaining >> 1);
    1412:	1a 01       	movw	r2, r20
    1414:	36 94       	lsr	r3
    1416:	27 94       	ror	r2
					
						union
						{
							uint16_t Words[2];
							uint32_t Long;
						} CurrFlashAddress                 = {.Words = {StartAddr, Flash64KBPage}};
    1418:	c9 01       	movw	r24, r18
    141a:	a0 91 60 01 	lds	r26, 0x0160
    141e:	b0 e0       	ldi	r27, 0x00	; 0
						
						uint32_t CurrFlashPageStartAddress = CurrFlashAddress.Long;
    1420:	9c 01       	movw	r18, r24
    1422:	ad 01       	movw	r20, r26
    1424:	62 e0       	ldi	r22, 0x02	; 2
    1426:	e6 2e       	mov	r14, r22
    1428:	f1 2c       	mov	r15, r1
    142a:	01 2d       	mov	r16, r1
    142c:	11 2d       	mov	r17, r1
    142e:	e2 0e       	add	r14, r18
    1430:	f3 1e       	adc	r15, r19
    1432:	04 1f       	adc	r16, r20
    1434:	15 1f       	adc	r17, r21
    1436:	59 01       	movw	r10, r18
    1438:	6a 01       	movw	r12, r20
    143a:	90 e0       	ldi	r25, 0x00	; 0
									  return;
								}
							}

							/* Write the next word into the current flash page */
							boot_page_fill(CurrFlashAddress.Long, Endpoint_Read_Word_LE());
    143c:	99 24       	eor	r9, r9
    143e:	93 94       	inc	r9

							/* See if an entire page has been written to the flash page buffer */
							if ((WordsInFlashPage == (SPM_PAGESIZE >> 1)) || !(WordsRemaining))
							{
								/* Commit the flash page to memory */
								boot_page_write(CurrFlashPageStartAddress);
    1440:	b5 e0       	ldi	r27, 0x05	; 5
								{
									CurrFlashPageStartAddress = CurrFlashAddress.Long;
									WordsInFlashPage          = 0;

									/* Erase next page's temp buffer */
									boot_page_erase(CurrFlashAddress.Long);
    1442:	a3 e0       	ldi	r26, 0x03	; 3
    1444:	48 c0       	rjmp	.+144    	; 0x14d6 <EVENT_USB_Device_UnhandledControlRequest+0x232>
    1446:	80 91 f2 00 	lds	r24, 0x00F2
						uint8_t  WordsInFlashPage          = 0;

						while (WordsRemaining--)
						{
							/* Check if endpoint is empty - if so clear it and wait until ready for next packet */
							if (!(Endpoint_BytesInEndpoint()))
    144a:	88 23       	and	r24, r24
    144c:	71 f4       	brne	.+28     	; 0x146a <EVENT_USB_Device_UnhandledControlRequest+0x1c6>
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << RXOUTI);	
    144e:	80 91 e8 00 	lds	r24, 0x00E8
    1452:	8b 7f       	andi	r24, 0xFB	; 251
    1454:	80 93 e8 00 	sts	0x00E8, r24
    1458:	04 c0       	rjmp	.+8      	; 0x1462 <EVENT_USB_Device_UnhandledControlRequest+0x1be>
							{
								Endpoint_ClearOUT();

								while (!(Endpoint_IsOUTReceived()))
								{				
									if (USB_DeviceState == DEVICE_STATE_Unattached)
    145a:	8e b3       	in	r24, 0x1e	; 30
    145c:	88 23       	and	r24, r24
    145e:	09 f4       	brne	.+2      	; 0x1462 <EVENT_USB_Device_UnhandledControlRequest+0x1be>
    1460:	4b c1       	rjmp	.+662    	; 0x16f8 <EVENT_USB_Device_UnhandledControlRequest+0x454>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1462:	80 91 e8 00 	lds	r24, 0x00E8
							/* Check if endpoint is empty - if so clear it and wait until ready for next packet */
							if (!(Endpoint_BytesInEndpoint()))
							{
								Endpoint_ClearOUT();

								while (!(Endpoint_IsOUTReceived()))
    1466:	82 ff       	sbrs	r24, 2
    1468:	f8 cf       	rjmp	.-16     	; 0x145a <EVENT_USB_Device_UnhandledControlRequest+0x1b6>
						} CurrFlashAddress                 = {.Words = {StartAddr, Flash64KBPage}};
						
						uint32_t CurrFlashPageStartAddress = CurrFlashAddress.Long;
						uint8_t  WordsInFlashPage          = 0;

						while (WordsRemaining--)
    146a:	08 94       	sec
    146c:	21 08       	sbc	r2, r1
    146e:	31 08       	sbc	r3, r1
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;
				
				Data.Bytes[0] = UEDATX;
    1470:	80 91 f1 00 	lds	r24, 0x00F1
    1474:	68 2f       	mov	r22, r24
				Data.Bytes[1] = UEDATX;
    1476:	80 91 f1 00 	lds	r24, 0x00F1
    147a:	78 2f       	mov	r23, r24
									  return;
								}
							}

							/* Write the next word into the current flash page */
							boot_page_fill(CurrFlashAddress.Long, Endpoint_Read_Word_LE());
    147c:	f5 01       	movw	r30, r10
    147e:	0b 01       	movw	r0, r22
    1480:	90 92 57 00 	sts	0x0057, r9
    1484:	e8 95       	spm
    1486:	11 24       	eor	r1, r1

							/* Adjust counters */
							WordsInFlashPage      += 1;
    1488:	9f 5f       	subi	r25, 0xFF	; 255
							CurrFlashAddress.Long += 2;

							/* See if an entire page has been written to the flash page buffer */
							if ((WordsInFlashPage == (SPM_PAGESIZE >> 1)) || !(WordsRemaining))
    148a:	90 34       	cpi	r25, 0x40	; 64
    148c:	19 f0       	breq	.+6      	; 0x1494 <EVENT_USB_Device_UnhandledControlRequest+0x1f0>
    148e:	21 14       	cp	r2, r1
    1490:	31 04       	cpc	r3, r1
    1492:	a1 f4       	brne	.+40     	; 0x14bc <EVENT_USB_Device_UnhandledControlRequest+0x218>
							{
								/* Commit the flash page to memory */
								boot_page_write(CurrFlashPageStartAddress);
    1494:	f9 01       	movw	r30, r18
    1496:	b0 93 57 00 	sts	0x0057, r27
    149a:	e8 95       	spm
								boot_spm_busy_wait();
    149c:	07 b6       	in	r0, 0x37	; 55
    149e:	00 fc       	sbrc	r0, 0
    14a0:	fd cf       	rjmp	.-6      	; 0x149c <EVENT_USB_Device_UnhandledControlRequest+0x1f8>
								
								/* Check if programming incomplete */
								if (WordsRemaining)
    14a2:	21 14       	cp	r2, r1
    14a4:	31 04       	cpc	r3, r1
    14a6:	51 f0       	breq	.+20     	; 0x14bc <EVENT_USB_Device_UnhandledControlRequest+0x218>
								{
									CurrFlashPageStartAddress = CurrFlashAddress.Long;
									WordsInFlashPage          = 0;

									/* Erase next page's temp buffer */
									boot_page_erase(CurrFlashAddress.Long);
    14a8:	f7 01       	movw	r30, r14
    14aa:	a0 93 57 00 	sts	0x0057, r26
    14ae:	e8 95       	spm
									boot_spm_busy_wait();
    14b0:	07 b6       	in	r0, 0x37	; 55
    14b2:	00 fc       	sbrc	r0, 0
    14b4:	fd cf       	rjmp	.-6      	; 0x14b0 <EVENT_USB_Device_UnhandledControlRequest+0x20c>
    14b6:	a8 01       	movw	r20, r16
    14b8:	97 01       	movw	r18, r14
    14ba:	90 e0       	ldi	r25, 0x00	; 0
    14bc:	42 e0       	ldi	r20, 0x02	; 2
    14be:	44 2e       	mov	r4, r20
    14c0:	51 2c       	mov	r5, r1
    14c2:	61 2c       	mov	r6, r1
    14c4:	71 2c       	mov	r7, r1
    14c6:	e4 0c       	add	r14, r4
    14c8:	f5 1c       	adc	r15, r5
    14ca:	06 1d       	adc	r16, r6
    14cc:	17 1d       	adc	r17, r7
    14ce:	a4 0c       	add	r10, r4
    14d0:	b5 1c       	adc	r11, r5
    14d2:	c6 1c       	adc	r12, r6
    14d4:	d7 1c       	adc	r13, r7
						} CurrFlashAddress                 = {.Words = {StartAddr, Flash64KBPage}};
						
						uint32_t CurrFlashPageStartAddress = CurrFlashAddress.Long;
						uint8_t  WordsInFlashPage          = 0;

						while (WordsRemaining--)
    14d6:	21 14       	cp	r2, r1
    14d8:	31 04       	cpc	r3, r1
    14da:	09 f0       	breq	.+2      	; 0x14de <EVENT_USB_Device_UnhandledControlRequest+0x23a>
    14dc:	b4 cf       	rjmp	.-152    	; 0x1446 <EVENT_USB_Device_UnhandledControlRequest+0x1a2>
								}
							}
						}
					
						/* Once programming complete, start address equals the end address */
						StartAddr = EndAddr;
    14de:	d0 93 62 01 	sts	0x0162, r29
    14e2:	c0 93 61 01 	sts	0x0161, r28
					
						/* Re-enable the RWW section of flash */
						boot_rww_enable();
    14e6:	81 e1       	ldi	r24, 0x11	; 17
    14e8:	80 93 57 00 	sts	0x0057, r24
    14ec:	e8 95       	spm
    14ee:	2a c0       	rjmp	.+84     	; 0x1544 <EVENT_USB_Device_UnhandledControlRequest+0x2a0>
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
    14f0:	80 91 f2 00 	lds	r24, 0x00F2
					else                                                   // Write EEPROM
					{
						while (BytesRemaining--)
						{
							/* Check if endpoint is empty - if so clear it and wait until ready for next packet */
							if (!(Endpoint_BytesInEndpoint()))
    14f4:	88 23       	and	r24, r24
    14f6:	71 f4       	brne	.+28     	; 0x1514 <EVENT_USB_Device_UnhandledControlRequest+0x270>
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << RXOUTI);	
    14f8:	80 91 e8 00 	lds	r24, 0x00E8
    14fc:	8b 7f       	andi	r24, 0xFB	; 251
    14fe:	80 93 e8 00 	sts	0x00E8, r24
    1502:	04 c0       	rjmp	.+8      	; 0x150c <EVENT_USB_Device_UnhandledControlRequest+0x268>
							{
								Endpoint_ClearOUT();

								while (!(Endpoint_IsOUTReceived()))
								{				
									if (USB_DeviceState == DEVICE_STATE_Unattached)
    1504:	8e b3       	in	r24, 0x1e	; 30
    1506:	88 23       	and	r24, r24
    1508:	09 f4       	brne	.+2      	; 0x150c <EVENT_USB_Device_UnhandledControlRequest+0x268>
    150a:	9e c0       	rjmp	.+316    	; 0x1648 <EVENT_USB_Device_UnhandledControlRequest+0x3a4>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    150c:	80 91 e8 00 	lds	r24, 0x00E8
							/* Check if endpoint is empty - if so clear it and wait until ready for next packet */
							if (!(Endpoint_BytesInEndpoint()))
							{
								Endpoint_ClearOUT();

								while (!(Endpoint_IsOUTReceived()))
    1510:	82 ff       	sbrs	r24, 2
    1512:	f8 cf       	rjmp	.-16     	; 0x1504 <EVENT_USB_Device_UnhandledControlRequest+0x260>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    1514:	80 91 f1 00 	lds	r24, 0x00F1
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1518:	f9 99       	sbic	0x1f, 1	; 31
    151a:	fe cf       	rjmp	.-4      	; 0x1518 <EVENT_USB_Device_UnhandledControlRequest+0x274>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    151c:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    151e:	32 bd       	out	0x22, r19	; 34
    1520:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
    1522:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    1524:	0f b6       	in	r0, 0x3f	; 63
    1526:	f8 94       	cli
    1528:	fa 9a       	sbi	0x1f, 2	; 31
    152a:	f9 9a       	sbi	0x1f, 1	; 31
    152c:	0f be       	out	0x3f, r0	; 63
    152e:	41 50       	subi	r20, 0x01	; 1
    1530:	50 40       	sbci	r21, 0x00	; 0
    1532:	2f 5f       	subi	r18, 0xFF	; 255
    1534:	3f 4f       	sbci	r19, 0xFF	; 255
						/* Re-enable the RWW section of flash */
						boot_rww_enable();
					}
					else                                                   // Write EEPROM
					{
						while (BytesRemaining--)
    1536:	41 15       	cp	r20, r1
    1538:	51 05       	cpc	r21, r1
    153a:	d1 f6       	brne	.-76     	; 0x14f0 <EVENT_USB_Device_UnhandledControlRequest+0x24c>
    153c:	30 93 62 01 	sts	0x0162, r19
    1540:	20 93 61 01 	sts	0x0161, r18
							StartAddr++;
						}
					}
					
					/* Throw away the currently unused DFU file suffix */
					DiscardFillerBytes(DFU_FILE_SUFFIX_SIZE);
    1544:	80 e1       	ldi	r24, 0x10	; 16
    1546:	b2 dd       	rcall	.-1180   	; 0x10ac <DiscardFillerBytes>
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << RXOUTI);	
    1548:	80 91 e8 00 	lds	r24, 0x00E8
    154c:	8b 7f       	andi	r24, 0xFB	; 251
    154e:	c6 c0       	rjmp	.+396    	; 0x16dc <EVENT_USB_Device_UnhandledControlRequest+0x438>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1550:	80 91 e8 00 	lds	r24, 0x00E8
    1554:	87 7f       	andi	r24, 0xF7	; 247
    1556:	80 93 e8 00 	sts	0x00E8, r24
				PORTD |= LEDS_ALL_LEDS;
			}
			
			static inline void LEDs_TurnOnLEDs(const uint8_t LEDMask)
			{
				PORTD &= ~LEDMask;
    155a:	5d 98       	cbi	0x0b, 5	; 11
			break;
		case DFU_UPLOAD:
			Endpoint_ClearSETUP();
			
			LEDs_TurnOnLEDs(LEDMASK_TX);
			PulseMSRemaining.TxLEDPulse = TX_RX_LED_PULSE_MS;
    155c:	83 e0       	ldi	r24, 0x03	; 3
    155e:	80 93 6d 01 	sts	0x016D, r24
    1562:	04 c0       	rjmp	.+8      	; 0x156c <EVENT_USB_Device_UnhandledControlRequest+0x2c8>

			while (!(Endpoint_IsINReady()))
			{				
				if (USB_DeviceState == DEVICE_STATE_Unattached)
    1564:	8e b3       	in	r24, 0x1e	; 30
    1566:	88 23       	and	r24, r24
    1568:	09 f4       	brne	.+2      	; 0x156c <EVENT_USB_Device_UnhandledControlRequest+0x2c8>
    156a:	c6 c0       	rjmp	.+396    	; 0x16f8 <EVENT_USB_Device_UnhandledControlRequest+0x454>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI))  ? true : false);
    156c:	80 91 e8 00 	lds	r24, 0x00E8
			Endpoint_ClearSETUP();
			
			LEDs_TurnOnLEDs(LEDMASK_TX);
			PulseMSRemaining.TxLEDPulse = TX_RX_LED_PULSE_MS;

			while (!(Endpoint_IsINReady()))
    1570:	80 ff       	sbrs	r24, 0
    1572:	f8 cf       	rjmp	.-16     	; 0x1564 <EVENT_USB_Device_UnhandledControlRequest+0x2c0>
			{				
				if (USB_DeviceState == DEVICE_STATE_Unattached)
				  return;
			}
							
			if (DFU_State != dfuUPLOAD_IDLE)
    1574:	80 91 01 01 	lds	r24, 0x0101
    1578:	89 30       	cpi	r24, 0x09	; 9
    157a:	91 f0       	breq	.+36     	; 0x15a0 <EVENT_USB_Device_UnhandledControlRequest+0x2fc>
			{
				if ((DFU_State == dfuERROR) && IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))       // Blank Check
    157c:	8a 30       	cpi	r24, 0x0A	; 10
    157e:	69 f4       	brne	.+26     	; 0x159a <EVENT_USB_Device_UnhandledControlRequest+0x2f6>
    1580:	80 91 66 01 	lds	r24, 0x0166
    1584:	81 30       	cpi	r24, 0x01	; 1
    1586:	49 f4       	brne	.+18     	; 0x159a <EVENT_USB_Device_UnhandledControlRequest+0x2f6>
				{
					/* Blank checking is performed in the DFU_DNLOAD request - if we get here we've told the host
					   that the memory isn't blank, and the host is requesting the first non-blank address */
					Endpoint_Write_Word_LE(StartAddr);
    1588:	80 91 61 01 	lds	r24, 0x0161
    158c:	90 91 62 01 	lds	r25, 0x0162
			 *  \param[in] Word  Next word to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Word_LE(const uint16_t Word) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Word_LE(const uint16_t Word)
			{
				UEDATX = (Word & 0xFF);
    1590:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Word >> 8);
    1594:	90 93 f1 00 	sts	0x00F1, r25
    1598:	9e c0       	rjmp	.+316    	; 0x16d6 <EVENT_USB_Device_UnhandledControlRequest+0x432>
				}
				else
				{
					/* Idle state upload - send response to last issued command */
					Endpoint_Write_Byte(ResponseByte);
    159a:	80 91 70 01 	lds	r24, 0x0170
    159e:	99 c0       	rjmp	.+306    	; 0x16d2 <EVENT_USB_Device_UnhandledControlRequest+0x42e>
				}
			}
			else
			{
				/* Determine the number of bytes remaining in the current block */
				uint16_t BytesRemaining = ((EndAddr - StartAddr) + 1);
    15a0:	60 91 63 01 	lds	r22, 0x0163
    15a4:	70 91 64 01 	lds	r23, 0x0164
    15a8:	20 91 61 01 	lds	r18, 0x0161
    15ac:	30 91 62 01 	lds	r19, 0x0162
    15b0:	6f 5f       	subi	r22, 0xFF	; 255
    15b2:	7f 4f       	sbci	r23, 0xFF	; 255
    15b4:	ab 01       	movw	r20, r22
    15b6:	42 1b       	sub	r20, r18
    15b8:	53 0b       	sbc	r21, r19
    15ba:	61 50       	subi	r22, 0x01	; 1
    15bc:	70 40       	sbci	r23, 0x00	; 0

				if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))            // Read FLASH
    15be:	80 91 66 01 	lds	r24, 0x0166
    15c2:	88 23       	and	r24, r24
    15c4:	89 f5       	brne	.+98     	; 0x1628 <EVENT_USB_Device_UnhandledControlRequest+0x384>
				{
					/* Calculate the number of words to be written from the number of bytes to be written */
					uint16_t WordsRemaining = (BytesRemaining >> 1);
    15c6:	8a 01       	movw	r16, r20
    15c8:	16 95       	lsr	r17
    15ca:	07 95       	ror	r16

					union
					{
						uint16_t Words[2];
						uint32_t Long;
					} CurrFlashAddress = {.Words = {StartAddr, Flash64KBPage}};
    15cc:	c9 01       	movw	r24, r18
    15ce:	a0 91 60 01 	lds	r26, 0x0160
    15d2:	b0 e0       	ldi	r27, 0x00	; 0
    15d4:	9c 01       	movw	r18, r24
    15d6:	ad 01       	movw	r20, r26
    15d8:	1f c0       	rjmp	.+62     	; 0x1618 <EVENT_USB_Device_UnhandledControlRequest+0x374>
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
    15da:	80 91 f2 00 	lds	r24, 0x00F2

					while (WordsRemaining--)
					{
						/* Check if endpoint is full - if so clear it and wait until ready for next packet */
						if (Endpoint_BytesInEndpoint() == FIXED_CONTROL_ENDPOINT_SIZE)
    15de:	80 32       	cpi	r24, 0x20	; 32
    15e0:	71 f4       	brne	.+28     	; 0x15fe <EVENT_USB_Device_UnhandledControlRequest+0x35a>
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << TXINI);
    15e2:	80 91 e8 00 	lds	r24, 0x00E8
    15e6:	8e 7f       	andi	r24, 0xFE	; 254
    15e8:	80 93 e8 00 	sts	0x00E8, r24
    15ec:	04 c0       	rjmp	.+8      	; 0x15f6 <EVENT_USB_Device_UnhandledControlRequest+0x352>
						{
							Endpoint_ClearIN();

							while (!(Endpoint_IsINReady()))
							{				
								if (USB_DeviceState == DEVICE_STATE_Unattached)
    15ee:	8e b3       	in	r24, 0x1e	; 30
    15f0:	88 23       	and	r24, r24
    15f2:	09 f4       	brne	.+2      	; 0x15f6 <EVENT_USB_Device_UnhandledControlRequest+0x352>
    15f4:	81 c0       	rjmp	.+258    	; 0x16f8 <EVENT_USB_Device_UnhandledControlRequest+0x454>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI))  ? true : false);
    15f6:	80 91 e8 00 	lds	r24, 0x00E8
						/* Check if endpoint is full - if so clear it and wait until ready for next packet */
						if (Endpoint_BytesInEndpoint() == FIXED_CONTROL_ENDPOINT_SIZE)
						{
							Endpoint_ClearIN();

							while (!(Endpoint_IsINReady()))
    15fa:	80 ff       	sbrs	r24, 0
    15fc:	f8 cf       	rjmp	.-16     	; 0x15ee <EVENT_USB_Device_UnhandledControlRequest+0x34a>

						/* Read the flash word and send it via USB to the host */
						#if (FLASHEND > 0xFFFF)
							Endpoint_Write_Word_LE(pgm_read_word_far(CurrFlashAddress.Long));
						#else
							Endpoint_Write_Word_LE(pgm_read_word(CurrFlashAddress.Long));							
    15fe:	f9 01       	movw	r30, r18
    1600:	85 91       	lpm	r24, Z+
    1602:	94 91       	lpm	r25, Z+
			 *  \param[in] Word  Next word to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Word_LE(const uint16_t Word) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Word_LE(const uint16_t Word)
			{
				UEDATX = (Word & 0xFF);
    1604:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Word >> 8);
    1608:	90 93 f1 00 	sts	0x00F1, r25
    160c:	01 50       	subi	r16, 0x01	; 1
    160e:	10 40       	sbci	r17, 0x00	; 0
    1610:	2e 5f       	subi	r18, 0xFE	; 254
    1612:	3f 4f       	sbci	r19, 0xFF	; 255
    1614:	4f 4f       	sbci	r20, 0xFF	; 255
    1616:	5f 4f       	sbci	r21, 0xFF	; 255
					{
						uint16_t Words[2];
						uint32_t Long;
					} CurrFlashAddress = {.Words = {StartAddr, Flash64KBPage}};

					while (WordsRemaining--)
    1618:	01 15       	cp	r16, r1
    161a:	11 05       	cpc	r17, r1
    161c:	f1 f6       	brne	.-68     	; 0x15da <EVENT_USB_Device_UnhandledControlRequest+0x336>
						/* Adjust counters */
						CurrFlashAddress.Long += 2;
					}
					
					/* Once reading is complete, start address equals the end address */
					StartAddr = EndAddr;
    161e:	70 93 62 01 	sts	0x0162, r23
    1622:	60 93 61 01 	sts	0x0161, r22
    1626:	2c c0       	rjmp	.+88     	; 0x1680 <EVENT_USB_Device_UnhandledControlRequest+0x3dc>
				}
				else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x02))       // Read EEPROM
    1628:	82 30       	cpi	r24, 0x02	; 2
    162a:	51 f5       	brne	.+84     	; 0x1680 <EVENT_USB_Device_UnhandledControlRequest+0x3dc>
    162c:	22 c0       	rjmp	.+68     	; 0x1672 <EVENT_USB_Device_UnhandledControlRequest+0x3ce>
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
    162e:	80 91 f2 00 	lds	r24, 0x00F2
				{
					while (BytesRemaining--)
					{
						/* Check if endpoint is full - if so clear it and wait until ready for next packet */
						if (Endpoint_BytesInEndpoint() == FIXED_CONTROL_ENDPOINT_SIZE)
    1632:	80 32       	cpi	r24, 0x20	; 32
    1634:	91 f4       	brne	.+36     	; 0x165a <EVENT_USB_Device_UnhandledControlRequest+0x3b6>
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << TXINI);
    1636:	80 91 e8 00 	lds	r24, 0x00E8
    163a:	8e 7f       	andi	r24, 0xFE	; 254
    163c:	80 93 e8 00 	sts	0x00E8, r24
    1640:	08 c0       	rjmp	.+16     	; 0x1652 <EVENT_USB_Device_UnhandledControlRequest+0x3ae>
						{
							Endpoint_ClearIN();
							
							while (!(Endpoint_IsINReady()))
							{				
								if (USB_DeviceState == DEVICE_STATE_Unattached)
    1642:	8e b3       	in	r24, 0x1e	; 30
    1644:	88 23       	and	r24, r24
    1646:	29 f4       	brne	.+10     	; 0x1652 <EVENT_USB_Device_UnhandledControlRequest+0x3ae>
    1648:	30 93 62 01 	sts	0x0162, r19
    164c:	20 93 61 01 	sts	0x0161, r18
    1650:	53 c0       	rjmp	.+166    	; 0x16f8 <EVENT_USB_Device_UnhandledControlRequest+0x454>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI))  ? true : false);
    1652:	80 91 e8 00 	lds	r24, 0x00E8
						/* Check if endpoint is full - if so clear it and wait until ready for next packet */
						if (Endpoint_BytesInEndpoint() == FIXED_CONTROL_ENDPOINT_SIZE)
						{
							Endpoint_ClearIN();
							
							while (!(Endpoint_IsINReady()))
    1656:	80 ff       	sbrs	r24, 0
    1658:	f4 cf       	rjmp	.-24     	; 0x1642 <EVENT_USB_Device_UnhandledControlRequest+0x39e>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    165a:	f9 99       	sbic	0x1f, 1	; 31
    165c:	fe cf       	rjmp	.-4      	; 0x165a <EVENT_USB_Device_UnhandledControlRequest+0x3b6>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    165e:	32 bd       	out	0x22, r19	; 34
    1660:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1662:	f8 9a       	sbi	0x1f, 0	; 31
    1664:	80 b5       	in	r24, 0x20	; 32
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    1666:	80 93 f1 00 	sts	0x00F1, r24
    166a:	41 50       	subi	r20, 0x01	; 1
    166c:	50 40       	sbci	r21, 0x00	; 0
    166e:	2f 5f       	subi	r18, 0xFF	; 255
    1670:	3f 4f       	sbci	r19, 0xFF	; 255
					/* Once reading is complete, start address equals the end address */
					StartAddr = EndAddr;
				}
				else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x02))       // Read EEPROM
				{
					while (BytesRemaining--)
    1672:	41 15       	cp	r20, r1
    1674:	51 05       	cpc	r21, r1
    1676:	d9 f6       	brne	.-74     	; 0x162e <EVENT_USB_Device_UnhandledControlRequest+0x38a>
    1678:	30 93 62 01 	sts	0x0162, r19
    167c:	20 93 61 01 	sts	0x0161, r18
						StartAddr++;
					}
				}

				/* Return to idle state */
				DFU_State = dfuIDLE;
    1680:	82 e0       	ldi	r24, 0x02	; 2
    1682:	80 93 01 01 	sts	0x0101, r24
    1686:	27 c0       	rjmp	.+78     	; 0x16d6 <EVENT_USB_Device_UnhandledControlRequest+0x432>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1688:	80 91 e8 00 	lds	r24, 0x00E8
    168c:	87 7f       	andi	r24, 0xF7	; 247
    168e:	80 93 e8 00 	sts	0x00E8, r24
			break;
		case DFU_GETSTATUS:
			Endpoint_ClearSETUP();
			
			/* Write 8-bit status value */
			Endpoint_Write_Byte(DFU_Status);
    1692:	80 91 5d 01 	lds	r24, 0x015D
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    1696:	80 93 f1 00 	sts	0x00F1, r24
			 *  \param[in] Word  Next word to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Word_LE(const uint16_t Word) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Word_LE(const uint16_t Word)
			{
				UEDATX = (Word & 0xFF);
    169a:	10 92 f1 00 	sts	0x00F1, r1
    169e:	10 92 f1 00 	sts	0x00F1, r1
				UEDATX = (Word >> 8);
    16a2:	10 92 f1 00 	sts	0x00F1, r1
			/* Write 24-bit poll timeout value */
			Endpoint_Write_Byte(0);
			Endpoint_Write_Word_LE(0);
			
			/* Write 8-bit state value */
			Endpoint_Write_Byte(DFU_State);
    16a6:	80 91 01 01 	lds	r24, 0x0101
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    16aa:	80 93 f1 00 	sts	0x00F1, r24
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    16ae:	10 92 f1 00 	sts	0x00F1, r1
    16b2:	11 c0       	rjmp	.+34     	; 0x16d6 <EVENT_USB_Device_UnhandledControlRequest+0x432>
    16b4:	80 91 e8 00 	lds	r24, 0x00E8
    16b8:	87 7f       	andi	r24, 0xF7	; 247
    16ba:	80 93 e8 00 	sts	0x00E8, r24
			break;		
		case DFU_CLRSTATUS:
			Endpoint_ClearSETUP();
			
			/* Reset the status value variable to the default OK status */
			DFU_Status = OK;
    16be:	10 92 5d 01 	sts	0x015D, r1
    16c2:	19 c0       	rjmp	.+50     	; 0x16f6 <EVENT_USB_Device_UnhandledControlRequest+0x452>
    16c4:	80 91 e8 00 	lds	r24, 0x00E8
    16c8:	87 7f       	andi	r24, 0xF7	; 247
    16ca:	80 93 e8 00 	sts	0x00E8, r24
			break;
		case DFU_GETSTATE:
			Endpoint_ClearSETUP();
			
			/* Write the current device state to the endpoint */
			Endpoint_Write_Byte(DFU_State);
    16ce:	80 91 01 01 	lds	r24, 0x0101
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    16d2:	80 93 f1 00 	sts	0x00F1, r24
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << TXINI);
    16d6:	80 91 e8 00 	lds	r24, 0x00E8
    16da:	8e 7f       	andi	r24, 0xFE	; 254
    16dc:	80 93 e8 00 	sts	0x00E8, r24
    16e0:	0a c0       	rjmp	.+20     	; 0x16f6 <EVENT_USB_Device_UnhandledControlRequest+0x452>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    16e2:	80 91 e8 00 	lds	r24, 0x00E8
    16e6:	87 7f       	andi	r24, 0xF7	; 247
    16e8:	80 93 e8 00 	sts	0x00E8, r24
			}

			static inline void LEDs_TurnOffLEDs(const uint8_t LEDMask)
			{
				PORTD |= LEDMask;
    16ec:	5d 9a       	sbi	0x0b, 5	; 11
			/* Turn off TX/RX status LEDs so that they're not left on when application starts */
			LEDs_TurnOffLEDs(LEDMASK_TX);
			LEDs_TurnOffLEDs(LEDMASK_RX);
			
			/* Reset the current state variable to the default idle state */
			DFU_State = dfuIDLE;
    16ee:	5c 9a       	sbi	0x0b, 4	; 11
    16f0:	82 e0       	ldi	r24, 0x02	; 2
    16f2:	80 93 01 01 	sts	0x0101, r24

			Endpoint_ClearStatusStage();
    16f6:	8f d0       	rcall	.+286    	; 0x1816 <Endpoint_ClearStatusStage>
			break;
	}
}
    16f8:	df 91       	pop	r29
    16fa:	cf 91       	pop	r28
    16fc:	1f 91       	pop	r17
    16fe:	0f 91       	pop	r16
    1700:	ff 90       	pop	r15
    1702:	ef 90       	pop	r14
    1704:	df 90       	pop	r13
    1706:	cf 90       	pop	r12
    1708:	bf 90       	pop	r11
    170a:	af 90       	pop	r10
    170c:	9f 90       	pop	r9
    170e:	7f 90       	pop	r7
    1710:	6f 90       	pop	r6
    1712:	5f 90       	pop	r5
    1714:	4f 90       	pop	r4
    1716:	3f 90       	pop	r3
    1718:	2f 90       	pop	r2
    171a:	08 95       	ret

0000171c <ResetHardware>:

/** Resets all configured hardware required for the bootloader back to their original states. */
void ResetHardware(void)
{
	/* Shut down the USB subsystem */
	USB_ShutDown();
    171c:	39 d1       	rcall	.+626    	; 0x1990 <USB_ShutDown>
	
	/* Relocate the interrupt vector table back to the application section */
	MCUCR = (1 << IVCE);
    171e:	81 e0       	ldi	r24, 0x01	; 1
    1720:	85 bf       	out	0x35, r24	; 53
	MCUCR = 0;
    1722:	15 be       	out	0x35, r1	; 53
}
    1724:	08 95       	ret

00001726 <SetupHardware>:

/** Configures all hardware required for the bootloader. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
    1726:	84 b7       	in	r24, 0x34	; 52
    1728:	87 7f       	andi	r24, 0xF7	; 247
    172a:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
    172c:	88 e1       	ldi	r24, 0x18	; 24
    172e:	0f b6       	in	r0, 0x3f	; 63
    1730:	f8 94       	cli
    1732:	80 93 60 00 	sts	0x0060, r24
    1736:	10 92 60 00 	sts	0x0060, r1
    173a:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
//	clock_prescale_set(clock_div_1);
	
	/* Relocate the interrupt vector table to the bootloader section */
	MCUCR = (1 << IVCE);
    173c:	81 e0       	ldi	r24, 0x01	; 1
    173e:	85 bf       	out	0x35, r24	; 53
	MCUCR = (1 << IVSEL);
    1740:	82 e0       	ldi	r24, 0x02	; 2
    1742:	85 bf       	out	0x35, r24	; 53

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |= LEDS_ALL_LEDS;
    1744:	8a b1       	in	r24, 0x0a	; 10
    1746:	80 63       	ori	r24, 0x30	; 48
    1748:	8a b9       	out	0x0a, r24	; 10
				PORTD |= LEDS_ALL_LEDS;
    174a:	8b b1       	in	r24, 0x0b	; 11
    174c:	80 63       	ori	r24, 0x30	; 48
    174e:	8b b9       	out	0x0b, r24	; 11

	LEDs_Init();

	/* Initialize the USB subsystem */
	USB_Init();
}
    1750:	1a c1       	rjmp	.+564    	; 0x1986 <USB_Init>

00001752 <main>:
 *  the loaded application code.
 */
int main(void)
{
	/* Configure hardware required by the bootloader */
	SetupHardware();
    1752:	e9 df       	rcall	.-46     	; 0x1726 <SetupHardware>
	
	/* Enable global interrupts so that the USB stack can function */
	sei();
    1754:	78 94       	sei
    1756:	01 c0       	rjmp	.+2      	; 0x175a <main+0x8>

	/* Run the USB management task while the bootloader is supposed to be running */
	while (RunBootloader || WaitForExit)
	  USB_USBTask();
    1758:	33 d3       	rcall	.+1638   	; 0x1dc0 <USB_USBTask>
	
	/* Enable global interrupts so that the USB stack can function */
	sei();

	/* Run the USB management task while the bootloader is supposed to be running */
	while (RunBootloader || WaitForExit)
    175a:	80 91 00 01 	lds	r24, 0x0100
    175e:	88 23       	and	r24, r24
    1760:	d9 f7       	brne	.-10     	; 0x1758 <main+0x6>
    1762:	80 91 5c 01 	lds	r24, 0x015C
    1766:	88 23       	and	r24, r24
    1768:	b9 f7       	brne	.-18     	; 0x1758 <main+0x6>
	  USB_USBTask();
	
	/* Reset configured hardware back to their original states for the user application */
	ResetHardware();
    176a:	d8 df       	rcall	.-80     	; 0x171c <ResetHardware>
	
	/* Start the user application */
	AppStartPtr();
    176c:	e0 91 5e 01 	lds	r30, 0x015E
    1770:	f0 91 5f 01 	lds	r31, 0x015F
    1774:	09 95       	icall

00001776 <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    void** const DescriptorAddress)
{
    1776:	fa 01       	movw	r30, r20
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	void*    Address = NULL;
	uint16_t Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
    1778:	92 30       	cpi	r25, 0x02	; 2
    177a:	71 f0       	breq	.+28     	; 0x1798 <CALLBACK_USB_GetDescriptor+0x22>
    177c:	93 30       	cpi	r25, 0x03	; 3
    177e:	89 f0       	breq	.+34     	; 0x17a2 <CALLBACK_USB_GetDescriptor+0x2c>
    1780:	91 30       	cpi	r25, 0x01	; 1
    1782:	29 f4       	brne	.+10     	; 0x178e <CALLBACK_USB_GetDescriptor+0x18>
    1784:	88 e0       	ldi	r24, 0x08	; 8
    1786:	91 e0       	ldi	r25, 0x01	; 1
    1788:	22 e1       	ldi	r18, 0x12	; 18
    178a:	30 e0       	ldi	r19, 0x00	; 0
    178c:	19 c0       	rjmp	.+50     	; 0x17c0 <CALLBACK_USB_GetDescriptor+0x4a>
    178e:	80 e0       	ldi	r24, 0x00	; 0
    1790:	90 e0       	ldi	r25, 0x00	; 0
    1792:	20 e0       	ldi	r18, 0x00	; 0
    1794:	30 e0       	ldi	r19, 0x00	; 0
    1796:	14 c0       	rjmp	.+40     	; 0x17c0 <CALLBACK_USB_GetDescriptor+0x4a>
    1798:	8a e1       	ldi	r24, 0x1A	; 26
    179a:	91 e0       	ldi	r25, 0x01	; 1
    179c:	2b e1       	ldi	r18, 0x1B	; 27
    179e:	30 e0       	ldi	r19, 0x00	; 0
    17a0:	0f c0       	rjmp	.+30     	; 0x17c0 <CALLBACK_USB_GetDescriptor+0x4a>
		case DTYPE_Configuration: 
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String: 
			if (!(DescriptorNumber))
    17a2:	88 23       	and	r24, r24
    17a4:	39 f4       	brne	.+14     	; 0x17b4 <CALLBACK_USB_GetDescriptor+0x3e>
			{
				Address = &LanguageString;
				Size    = LanguageString.Header.Size;
    17a6:	80 91 35 01 	lds	r24, 0x0135
    17aa:	28 2f       	mov	r18, r24
    17ac:	30 e0       	ldi	r19, 0x00	; 0
    17ae:	85 e3       	ldi	r24, 0x35	; 53
    17b0:	91 e0       	ldi	r25, 0x01	; 1
    17b2:	06 c0       	rjmp	.+12     	; 0x17c0 <CALLBACK_USB_GetDescriptor+0x4a>
			}
			else
			{
				Address = &ProductString;
				Size    = ProductString.Header.Size;
    17b4:	80 91 39 01 	lds	r24, 0x0139
    17b8:	28 2f       	mov	r18, r24
    17ba:	30 e0       	ldi	r19, 0x00	; 0
    17bc:	89 e3       	ldi	r24, 0x39	; 57
    17be:	91 e0       	ldi	r25, 0x01	; 1
			}
			
			break;
	}
	
	*DescriptorAddress = Address;
    17c0:	91 83       	std	Z+1, r25	; 0x01
    17c2:	80 83       	st	Z, r24
	return Size;
}
    17c4:	c9 01       	movw	r24, r18
    17c6:	08 95       	ret

000017c8 <Endpoint_ConfigureEndpoint_Prv>:
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    17c8:	80 93 e9 00 	sts	0x00E9, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    17cc:	80 91 eb 00 	lds	r24, 0x00EB
    17d0:	81 60       	ori	r24, 0x01	; 1
    17d2:	80 93 eb 00 	sts	0x00EB, r24
                                    const uint8_t UECFG1XData)
{
	Endpoint_SelectEndpoint(Number);
	Endpoint_EnableEndpoint();

	UECFG1X = 0;
    17d6:	10 92 ed 00 	sts	0x00ED, r1

	UECFG0X = UECFG0XData;
    17da:	60 93 ec 00 	sts	0x00EC, r22
	UECFG1X = UECFG1XData;
    17de:	40 93 ed 00 	sts	0x00ED, r20
			 *  \return Boolean true if the currently selected endpoint has been configured, false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    17e2:	80 91 ee 00 	lds	r24, 0x00EE

	return Endpoint_IsConfigured();
}
    17e6:	88 1f       	adc	r24, r24
    17e8:	88 27       	eor	r24, r24
    17ea:	88 1f       	adc	r24, r24
    17ec:	08 95       	ret

000017ee <Endpoint_ClearEndpoints>:

void Endpoint_ClearEndpoints(void)
{
	UEINT = 0;
    17ee:	10 92 f4 00 	sts	0x00F4, r1
    17f2:	90 e0       	ldi	r25, 0x00	; 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    17f4:	90 93 e9 00 	sts	0x00E9, r25

	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
	{
		Endpoint_SelectEndpoint(EPNum);	
		UEIENX  = 0;
    17f8:	10 92 f0 00 	sts	0x00F0, r1
		UEINTX  = 0;
    17fc:	10 92 e8 00 	sts	0x00E8, r1
		UECFG1X = 0;
    1800:	10 92 ed 00 	sts	0x00ED, r1
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    1804:	80 91 eb 00 	lds	r24, 0x00EB
    1808:	8e 7f       	andi	r24, 0xFE	; 254
    180a:	80 93 eb 00 	sts	0x00EB, r24

void Endpoint_ClearEndpoints(void)
{
	UEINT = 0;

	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    180e:	9f 5f       	subi	r25, 0xFF	; 255
    1810:	95 30       	cpi	r25, 0x05	; 5
    1812:	81 f7       	brne	.-32     	; 0x17f4 <Endpoint_ClearEndpoints+0x6>
		UEIENX  = 0;
		UEINTX  = 0;
		UECFG1X = 0;
		Endpoint_DisableEndpoint();
	}
}
    1814:	08 95       	ret

00001816 <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    1816:	80 91 75 01 	lds	r24, 0x0175
    181a:	88 23       	and	r24, r24
    181c:	8c f4       	brge	.+34     	; 0x1840 <Endpoint_ClearStatusStage+0x2a>
    181e:	03 c0       	rjmp	.+6      	; 0x1826 <Endpoint_ClearStatusStage+0x10>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1820:	8e b3       	in	r24, 0x1e	; 30
    1822:	88 23       	and	r24, r24
    1824:	b1 f0       	breq	.+44     	; 0x1852 <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1826:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    182a:	82 ff       	sbrs	r24, 2
    182c:	f9 cf       	rjmp	.-14     	; 0x1820 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    182e:	80 91 e8 00 	lds	r24, 0x00E8
    1832:	8b 77       	andi	r24, 0x7B	; 123
    1834:	80 93 e8 00 	sts	0x00E8, r24
    1838:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    183a:	8e b3       	in	r24, 0x1e	; 30
    183c:	88 23       	and	r24, r24
    183e:	49 f0       	breq	.+18     	; 0x1852 <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI))  ? true : false);
    1840:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    1844:	80 ff       	sbrs	r24, 0
    1846:	f9 cf       	rjmp	.-14     	; 0x183a <Endpoint_ClearStatusStage+0x24>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1848:	80 91 e8 00 	lds	r24, 0x00E8
    184c:	8e 77       	andi	r24, 0x7E	; 126
    184e:	80 93 e8 00 	sts	0x00E8, r24
    1852:	08 95       	ret

00001854 <Endpoint_Write_Control_PStream_LE>:
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
    1854:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;
	
	if (Length > USB_ControlRequest.wLength)
    1856:	40 91 7b 01 	lds	r20, 0x017B
    185a:	50 91 7c 01 	lds	r21, 0x017C
    185e:	46 17       	cp	r20, r22
    1860:	57 07       	cpc	r21, r23
    1862:	10 f4       	brcc	.+4      	; 0x1868 <Endpoint_Write_Control_PStream_LE+0x14>
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1864:	90 e0       	ldi	r25, 0x00	; 0
    1866:	3b c0       	rjmp	.+118    	; 0x18de <Endpoint_Write_Control_PStream_LE+0x8a>
	bool     LastPacketFull = false;
	
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1868:	61 15       	cp	r22, r1
    186a:	71 05       	cpc	r23, r1
    186c:	11 f0       	breq	.+4      	; 0x1872 <Endpoint_Write_Control_PStream_LE+0x1e>
    186e:	ab 01       	movw	r20, r22
    1870:	f9 cf       	rjmp	.-14     	; 0x1864 <Endpoint_Write_Control_PStream_LE+0x10>
    1872:	80 91 e8 00 	lds	r24, 0x00E8
    1876:	8e 77       	andi	r24, 0x7E	; 126
    1878:	80 93 e8 00 	sts	0x00E8, r24
    187c:	40 e0       	ldi	r20, 0x00	; 0
    187e:	50 e0       	ldi	r21, 0x00	; 0
    1880:	f1 cf       	rjmp	.-30     	; 0x1864 <Endpoint_Write_Control_PStream_LE+0x10>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1882:	80 91 e8 00 	lds	r24, 0x00E8
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		if (Endpoint_IsSETUPReceived())
    1886:	83 ff       	sbrs	r24, 3
    1888:	02 c0       	rjmp	.+4      	; 0x188e <Endpoint_Write_Control_PStream_LE+0x3a>
    188a:	81 e0       	ldi	r24, 0x01	; 1
    188c:	08 95       	ret
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    188e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    1892:	82 fd       	sbrc	r24, 2
    1894:	30 c0       	rjmp	.+96     	; 0x18f6 <Endpoint_Write_Control_PStream_LE+0xa2>
		  break;
		
		if (USB_DeviceState == DEVICE_STATE_Unattached)
    1896:	8e b3       	in	r24, 0x1e	; 30
    1898:	88 23       	and	r24, r24
    189a:	99 f1       	breq	.+102    	; 0x1902 <Endpoint_Write_Control_PStream_LE+0xae>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState == DEVICE_STATE_Suspended)
    189c:	8e b3       	in	r24, 0x1e	; 30
    189e:	85 30       	cpi	r24, 0x05	; 5
    18a0:	91 f1       	breq	.+100    	; 0x1906 <Endpoint_Write_Control_PStream_LE+0xb2>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI))  ? true : false);
    18a2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		  
		if (Endpoint_IsINReady())
    18a6:	80 ff       	sbrs	r24, 0
    18a8:	1a c0       	rjmp	.+52     	; 0x18de <Endpoint_Write_Control_PStream_LE+0x8a>
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
    18aa:	80 91 f2 00 	lds	r24, 0x00F2
    18ae:	09 c0       	rjmp	.+18     	; 0x18c2 <Endpoint_Write_Control_PStream_LE+0x6e>
		{
			uint8_t BytesInEndpoint = Endpoint_BytesInEndpoint();
		
			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    18b0:	f9 01       	movw	r30, r18
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    18b2:	2f 5f       	subi	r18, 0xFF	; 255
    18b4:	3f 4f       	sbci	r19, 0xFF	; 255
    18b6:	e4 91       	lpm	r30, Z+
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    18b8:	e0 93 f1 00 	sts	0x00F1, r30
				Length--;
    18bc:	41 50       	subi	r20, 0x01	; 1
    18be:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    18c0:	8f 5f       	subi	r24, 0xFF	; 255
		  
		if (Endpoint_IsINReady())
		{
			uint8_t BytesInEndpoint = Endpoint_BytesInEndpoint();
		
			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    18c2:	41 15       	cp	r20, r1
    18c4:	51 05       	cpc	r21, r1
    18c6:	11 f0       	breq	.+4      	; 0x18cc <Endpoint_Write_Control_PStream_LE+0x78>
    18c8:	88 30       	cpi	r24, 0x08	; 8
    18ca:	90 f3       	brcs	.-28     	; 0x18b0 <Endpoint_Write_Control_PStream_LE+0x5c>
				TEMPLATE_TRANSFER_BYTE(DataStream);
				Length--;
				BytesInEndpoint++;
			}
			
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
    18cc:	90 e0       	ldi	r25, 0x00	; 0
    18ce:	88 30       	cpi	r24, 0x08	; 8
    18d0:	09 f4       	brne	.+2      	; 0x18d4 <Endpoint_Write_Control_PStream_LE+0x80>
    18d2:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    18d4:	80 91 e8 00 	lds	r24, 0x00E8
    18d8:	8e 77       	andi	r24, 0x7E	; 126
    18da:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    18de:	41 15       	cp	r20, r1
    18e0:	51 05       	cpc	r21, r1
    18e2:	79 f6       	brne	.-98     	; 0x1882 <Endpoint_Write_Control_PStream_LE+0x2e>
    18e4:	99 23       	and	r25, r25
    18e6:	69 f6       	brne	.-102    	; 0x1882 <Endpoint_Write_Control_PStream_LE+0x2e>
    18e8:	06 c0       	rjmp	.+12     	; 0x18f6 <Endpoint_Write_Control_PStream_LE+0xa2>
		}
	}
	
	while (!(Endpoint_IsOUTReceived()))
	{
		if (USB_DeviceState == DEVICE_STATE_Unattached)
    18ea:	8e b3       	in	r24, 0x1e	; 30
    18ec:	88 23       	and	r24, r24
    18ee:	49 f0       	breq	.+18     	; 0x1902 <Endpoint_Write_Control_PStream_LE+0xae>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState == DEVICE_STATE_Suspended)
    18f0:	8e b3       	in	r24, 0x1e	; 30
    18f2:	85 30       	cpi	r24, 0x05	; 5
    18f4:	41 f0       	breq	.+16     	; 0x1906 <Endpoint_Write_Control_PStream_LE+0xb2>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    18f6:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}
	
	while (!(Endpoint_IsOUTReceived()))
    18fa:	82 ff       	sbrs	r24, 2
    18fc:	f6 cf       	rjmp	.-20     	; 0x18ea <Endpoint_Write_Control_PStream_LE+0x96>
    18fe:	80 e0       	ldi	r24, 0x00	; 0
    1900:	08 95       	ret
    1902:	82 e0       	ldi	r24, 0x02	; 2
    1904:	08 95       	ret
    1906:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1908:	08 95       	ret

0000190a <USB_ResetInterface>:
	#endif
}

void USB_ResetInterface(void)
{
	USB_INT_DisableAllInterrupts();
    190a:	58 d0       	rcall	.+176    	; 0x19bc <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    190c:	5a d0       	rcall	.+180    	; 0x19c2 <USB_INT_ClearAllInterrupts>
	#if defined(USB_CAN_BE_HOST)
	USB_HostState   = HOST_STATE_Unattached;
	#endif
	
	#if defined(USB_CAN_BE_DEVICE)
	USB_DeviceState = DEVICE_STATE_Unattached;
    190e:	1e ba       	out	0x1e, r1	; 30
	USB_ConfigurationNumber  = 0;
    1910:	10 92 73 01 	sts	0x0173, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_RemoteWakeupEnabled  = false;
    1914:	10 92 72 01 	sts	0x0172, r1
	#endif
	
	#if !defined(NO_DEVICE_SELF_POWER)
	USB_CurrentlySelfPowered = false;
    1918:	10 92 71 01 	sts	0x0171, r1
	#if !defined(__DOXYGEN__)
		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
    191c:	84 e0       	ldi	r24, 0x04	; 4
    191e:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
    1920:	89 b5       	in	r24, 0x29	; 41
    1922:	82 60       	ori	r24, 0x02	; 2
    1924:	89 bd       	out	0x29, r24	; 41
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = ((1 << PLLUSB) | (1 << PDIV3) | (1 << PDIV1));
		#endif

		USB_PLL_On();
		while (!(USB_PLL_IsReady()));
    1926:	09 b4       	in	r0, 0x29	; 41
    1928:	00 fe       	sbrs	r0, 0
    192a:	fd cf       	rjmp	.-6      	; 0x1926 <USB_ResetInterface+0x1c>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				const uint8_t Temp = USBCON;
    192c:	80 91 d8 00 	lds	r24, 0x00D8
				
				USBCON = (Temp & ~(1 << USBE));
    1930:	98 2f       	mov	r25, r24
    1932:	9f 77       	andi	r25, 0x7F	; 127
    1934:	90 93 d8 00 	sts	0x00D8, r25
				USBCON = (Temp |  (1 << USBE));
    1938:	80 68       	ori	r24, 0x80	; 128
    193a:	80 93 d8 00 	sts	0x00D8, r24
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
			#else
				REGCR   &= ~(1 << REGDIS);
    193e:	80 91 63 00 	lds	r24, 0x0063
    1942:	8e 7f       	andi	r24, 0xFE	; 254
    1944:	80 93 63 00 	sts	0x0063, r24
			}
			
			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    1948:	80 91 d8 00 	lds	r24, 0x00D8
    194c:	8f 7d       	andi	r24, 0xDF	; 223
    194e:	80 93 d8 00 	sts	0x00D8, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    1952:	80 91 e0 00 	lds	r24, 0x00E0
    1956:	8e 7f       	andi	r24, 0xFE	; 254
    1958:	80 93 e0 00 	sts	0x00E0, r24
	#endif

	USB_Attach();
	
	#if defined(USB_DEVICE_ONLY)
	USB_INT_Clear(USB_INT_SUSPEND);
    195c:	80 91 e1 00 	lds	r24, 0x00E1
    1960:	8e 7f       	andi	r24, 0xFE	; 254
    1962:	80 93 e1 00 	sts	0x00E1, r24
	USB_INT_Enable(USB_INT_SUSPEND);
    1966:	80 91 e2 00 	lds	r24, 0x00E2
    196a:	81 60       	ori	r24, 0x01	; 1
    196c:	80 93 e2 00 	sts	0x00E2, r24
	USB_INT_Clear(USB_INT_EORSTI);
    1970:	80 91 e1 00 	lds	r24, 0x00E1
    1974:	87 7f       	andi	r24, 0xF7	; 247
    1976:	80 93 e1 00 	sts	0x00E1, r24
	USB_INT_Enable(USB_INT_EORSTI);
    197a:	80 91 e2 00 	lds	r24, 0x00E2
    197e:	88 60       	ori	r24, 0x08	; 8
    1980:	80 93 e2 00 	sts	0x00E2, r24
		
		USB_INT_Enable(USB_INT_SRPI);
		USB_INT_Enable(USB_INT_BCERRI);
	}
	#endif
}
    1984:	08 95       	ret

00001986 <USB_Init>:
		EVENT_USB_InitFailure(USB_INITERROR_NoUSBModeSpecified);
		return;
	}
	#endif
	
	USB_ResetInterface();
    1986:	c1 df       	rcall	.-126    	; 0x190a <USB_ResetInterface>

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USB_OTGPAD_On();
	#endif

	USB_IsInitialized = true;
    1988:	81 e0       	ldi	r24, 0x01	; 1
    198a:	80 93 74 01 	sts	0x0174, r24
}
    198e:	08 95       	ret

00001990 <USB_ShutDown>:

void USB_ShutDown(void)
{
	USB_ResetInterface();
    1990:	bc df       	rcall	.-136    	; 0x190a <USB_ResetInterface>
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
    1992:	e0 ee       	ldi	r30, 0xE0	; 224
    1994:	f0 e0       	ldi	r31, 0x00	; 0
    1996:	80 81       	ld	r24, Z
    1998:	81 60       	ori	r24, 0x01	; 1
    199a:	80 83       	st	Z, r24
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USBCON  &= ~(1 << USBE);
    199c:	e8 ed       	ldi	r30, 0xD8	; 216
    199e:	f0 e0       	ldi	r31, 0x00	; 0
    19a0:	80 81       	ld	r24, Z
    19a2:	8f 77       	andi	r24, 0x7F	; 127
    19a4:	80 83       	st	Z, r24
	USB_Detach();
	USB_Controller_Disable();
	
	USB_INT_DisableAllInterrupts();
    19a6:	0a d0       	rcall	.+20     	; 0x19bc <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    19a8:	0c d0       	rcall	.+24     	; 0x19c2 <USB_INT_ClearAllInterrupts>
			}
			
			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR  = 0;
    19aa:	19 bc       	out	0x29, r1	; 41
			static inline void USB_REG_Off(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  &= ~(1 << UVREGE);
			#else
				REGCR   |=  (1 << REGDIS);
    19ac:	e3 e6       	ldi	r30, 0x63	; 99
    19ae:	f0 e0       	ldi	r31, 0x00	; 0
    19b0:	80 81       	ld	r24, Z
    19b2:	81 60       	ori	r24, 0x01	; 1
    19b4:	80 83       	st	Z, r24

	#if defined(USB_CAN_BE_BOTH)
	UHWCON &= ~(1 << UIDE);
	#endif

	USB_IsInitialized = false;
    19b6:	10 92 74 01 	sts	0x0174, r1

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_NONE;
	#endif
}
    19ba:	08 95       	ret

000019bc <USB_INT_DisableAllInterrupts>:
	UHIEN   = 0;
	OTGIEN  = 0;
	#endif
	
	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    19bc:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    19c0:	08 95       	ret

000019c2 <USB_INT_ClearAllInterrupts>:
	UHINT   = 0;
	OTGINT  = 0;
	#endif
	
	#if defined(USB_CAN_BE_DEVICE)
	UDINT   = 0;
    19c2:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    19c6:	08 95       	ret

000019c8 <__vector_12>:
	#endif
}

#if defined(INTERRUPT_CONTROL_ENDPOINT) && defined(USB_CAN_BE_DEVICE)
ISR(USB_COM_vect, ISR_BLOCK)
{
    19c8:	1f 92       	push	r1
    19ca:	0f 92       	push	r0
    19cc:	0f b6       	in	r0, 0x3f	; 63
    19ce:	0f 92       	push	r0
    19d0:	11 24       	eor	r1, r1
    19d2:	1f 93       	push	r17
    19d4:	2f 93       	push	r18
    19d6:	3f 93       	push	r19
    19d8:	4f 93       	push	r20
    19da:	5f 93       	push	r21
    19dc:	6f 93       	push	r22
    19de:	7f 93       	push	r23
    19e0:	8f 93       	push	r24
    19e2:	9f 93       	push	r25
    19e4:	af 93       	push	r26
    19e6:	bf 93       	push	r27
    19e8:	ef 93       	push	r30
    19ea:	ff 93       	push	r31
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    19ec:	e9 ee       	ldi	r30, 0xE9	; 233
    19ee:	f0 e0       	ldi	r31, 0x00	; 0
    19f0:	10 81       	ld	r17, Z
    19f2:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    19f4:	10 82       	st	Z, r1
	uint8_t PrevSelectedEndpoint = Endpoint_GetCurrentEndpoint(); 

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Disable(USB_INT_RXSTPI);
    19f6:	e0 ef       	ldi	r30, 0xF0	; 240
    19f8:	f0 e0       	ldi	r31, 0x00	; 0
    19fa:	80 81       	ld	r24, Z
    19fc:	87 7f       	andi	r24, 0xF7	; 247
    19fe:	80 83       	st	Z, r24

#if !defined(__DOXYGEN__)
/* Internal helper functions. */
static __inline__ uint8_t __iSeiRetVal(void)
{
    sei();
    1a00:	78 94       	sei

	NONATOMIC_BLOCK(NONATOMIC_FORCEOFF)
	{
		USB_Device_ProcessControlRequest();
    1a02:	c3 d0       	rcall	.+390    	; 0x1b8a <USB_Device_ProcessControlRequest>
    (void)__s;
}

static __inline__ void __iCliParam(const uint8_t *__s)
{
    cli();
    1a04:	f8 94       	cli
    1a06:	a9 ee       	ldi	r26, 0xE9	; 233
    1a08:	b0 e0       	ldi	r27, 0x00	; 0
    1a0a:	1c 92       	st	X, r1
	}

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Enable(USB_INT_RXSTPI);
    1a0c:	e0 ef       	ldi	r30, 0xF0	; 240
    1a0e:	f0 e0       	ldi	r31, 0x00	; 0
    1a10:	80 81       	ld	r24, Z
    1a12:	88 60       	ori	r24, 0x08	; 8
    1a14:	80 83       	st	Z, r24
    1a16:	1c 93       	st	X, r17
	Endpoint_SelectEndpoint(PrevSelectedEndpoint);
}
    1a18:	ff 91       	pop	r31
    1a1a:	ef 91       	pop	r30
    1a1c:	bf 91       	pop	r27
    1a1e:	af 91       	pop	r26
    1a20:	9f 91       	pop	r25
    1a22:	8f 91       	pop	r24
    1a24:	7f 91       	pop	r23
    1a26:	6f 91       	pop	r22
    1a28:	5f 91       	pop	r21
    1a2a:	4f 91       	pop	r20
    1a2c:	3f 91       	pop	r19
    1a2e:	2f 91       	pop	r18
    1a30:	1f 91       	pop	r17
    1a32:	0f 90       	pop	r0
    1a34:	0f be       	out	0x3f, r0	; 63
    1a36:	0f 90       	pop	r0
    1a38:	1f 90       	pop	r1
    1a3a:	18 95       	reti

00001a3c <__vector_11>:
	UDINT   = 0;
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    1a3c:	1f 92       	push	r1
    1a3e:	0f 92       	push	r0
    1a40:	0f b6       	in	r0, 0x3f	; 63
    1a42:	0f 92       	push	r0
    1a44:	11 24       	eor	r1, r1
    1a46:	2f 93       	push	r18
    1a48:	3f 93       	push	r19
    1a4a:	4f 93       	push	r20
    1a4c:	5f 93       	push	r21
    1a4e:	6f 93       	push	r22
    1a50:	7f 93       	push	r23
    1a52:	8f 93       	push	r24
    1a54:	9f 93       	push	r25
    1a56:	af 93       	push	r26
    1a58:	bf 93       	push	r27
    1a5a:	ef 93       	push	r30
    1a5c:	ff 93       	push	r31
			EVENT_USB_Device_Disconnect();
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPEND) && USB_INT_IsEnabled(USB_INT_SUSPEND))
    1a5e:	80 91 e1 00 	lds	r24, 0x00E1
    1a62:	80 ff       	sbrs	r24, 0
    1a64:	1b c0       	rjmp	.+54     	; 0x1a9c <__vector_11+0x60>
    1a66:	80 91 e2 00 	lds	r24, 0x00E2
    1a6a:	80 ff       	sbrs	r24, 0
    1a6c:	17 c0       	rjmp	.+46     	; 0x1a9c <__vector_11+0x60>
	{
		USB_INT_Clear(USB_INT_SUSPEND);
    1a6e:	80 91 e1 00 	lds	r24, 0x00E1
    1a72:	8e 7f       	andi	r24, 0xFE	; 254
    1a74:	80 93 e1 00 	sts	0x00E1, r24

		USB_INT_Disable(USB_INT_SUSPEND);
    1a78:	80 91 e2 00 	lds	r24, 0x00E2
    1a7c:	8e 7f       	andi	r24, 0xFE	; 254
    1a7e:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_WAKEUP);
    1a82:	80 91 e2 00 	lds	r24, 0x00E2
    1a86:	80 61       	ori	r24, 0x10	; 16
    1a88:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    1a8c:	80 91 d8 00 	lds	r24, 0x00D8
    1a90:	80 62       	ori	r24, 0x20	; 32
    1a92:	80 93 d8 00 	sts	0x00D8, r24
			}
			
			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR  = 0;
    1a96:	19 bc       	out	0x29, r1	; 41
		
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		  USB_PLL_Off();

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
    1a98:	1e ba       	out	0x1e, r1	; 30
		EVENT_USB_Device_Disconnect();
    1a9a:	91 d1       	rcall	.+802    	; 0x1dbe <USB_Event_Stub>
		USB_DeviceState = DEVICE_STATE_Suspended;
		EVENT_USB_Device_Suspend();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUP) && USB_INT_IsEnabled(USB_INT_WAKEUP))
    1a9c:	80 91 e1 00 	lds	r24, 0x00E1
    1aa0:	84 ff       	sbrs	r24, 4
    1aa2:	29 c0       	rjmp	.+82     	; 0x1af6 <__vector_11+0xba>
    1aa4:	80 91 e2 00 	lds	r24, 0x00E2
    1aa8:	84 ff       	sbrs	r24, 4
    1aaa:	25 c0       	rjmp	.+74     	; 0x1af6 <__vector_11+0xba>
	#if !defined(__DOXYGEN__)
		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
    1aac:	84 e0       	ldi	r24, 0x04	; 4
    1aae:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
    1ab0:	89 b5       	in	r24, 0x29	; 41
    1ab2:	82 60       	ori	r24, 0x02	; 2
    1ab4:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    1ab6:	09 b4       	in	r0, 0x29	; 41
    1ab8:	00 fe       	sbrs	r0, 0
    1aba:	fd cf       	rjmp	.-6      	; 0x1ab6 <__vector_11+0x7a>
			}
			
			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    1abc:	80 91 d8 00 	lds	r24, 0x00D8
    1ac0:	8f 7d       	andi	r24, 0xDF	; 223
    1ac2:	80 93 d8 00 	sts	0x00D8, r24
		}

		USB_CLK_Unfreeze();

		USB_INT_Clear(USB_INT_WAKEUP);
    1ac6:	80 91 e1 00 	lds	r24, 0x00E1
    1aca:	8f 7e       	andi	r24, 0xEF	; 239
    1acc:	80 93 e1 00 	sts	0x00E1, r24

		USB_INT_Disable(USB_INT_WAKEUP);
    1ad0:	80 91 e2 00 	lds	r24, 0x00E2
    1ad4:	8f 7e       	andi	r24, 0xEF	; 239
    1ad6:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_SUSPEND);
    1ada:	80 91 e2 00 	lds	r24, 0x00E2
    1ade:	81 60       	ori	r24, 0x01	; 1
    1ae0:	80 93 e2 00 	sts	0x00E2, r24
		
		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    1ae4:	80 91 73 01 	lds	r24, 0x0173
    1ae8:	88 23       	and	r24, r24
    1aea:	11 f4       	brne	.+4      	; 0x1af0 <__vector_11+0xb4>
    1aec:	81 e0       	ldi	r24, 0x01	; 1
    1aee:	01 c0       	rjmp	.+2      	; 0x1af2 <__vector_11+0xb6>
    1af0:	84 e0       	ldi	r24, 0x04	; 4
    1af2:	8e bb       	out	0x1e, r24	; 30
		EVENT_USB_Device_Connect();
    1af4:	64 d1       	rcall	.+712    	; 0x1dbe <USB_Event_Stub>
		USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Addressed;
		EVENT_USB_Device_WakeUp();		
		#endif
	}
   
	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    1af6:	80 91 e1 00 	lds	r24, 0x00E1
    1afa:	83 ff       	sbrs	r24, 3
    1afc:	27 c0       	rjmp	.+78     	; 0x1b4c <__vector_11+0x110>
    1afe:	80 91 e2 00 	lds	r24, 0x00E2
    1b02:	83 ff       	sbrs	r24, 3
    1b04:	23 c0       	rjmp	.+70     	; 0x1b4c <__vector_11+0x110>
	{
		USB_INT_Clear(USB_INT_EORSTI);
    1b06:	80 91 e1 00 	lds	r24, 0x00E1
    1b0a:	87 7f       	andi	r24, 0xF7	; 247
    1b0c:	80 93 e1 00 	sts	0x00E1, r24

		USB_DeviceState         = DEVICE_STATE_Default;
    1b10:	82 e0       	ldi	r24, 0x02	; 2
    1b12:	8e bb       	out	0x1e, r24	; 30
		USB_ConfigurationNumber = 0;
    1b14:	10 92 73 01 	sts	0x0173, r1

		USB_INT_Clear(USB_INT_SUSPEND);
    1b18:	80 91 e1 00 	lds	r24, 0x00E1
    1b1c:	8e 7f       	andi	r24, 0xFE	; 254
    1b1e:	80 93 e1 00 	sts	0x00E1, r24
		USB_INT_Disable(USB_INT_SUSPEND);
    1b22:	80 91 e2 00 	lds	r24, 0x00E2
    1b26:	8e 7f       	andi	r24, 0xFE	; 254
    1b28:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_WAKEUP);
    1b2c:	80 91 e2 00 	lds	r24, 0x00E2
    1b30:	80 61       	ori	r24, 0x10	; 16
    1b32:	80 93 e2 00 	sts	0x00E2, r24

		Endpoint_ClearEndpoints();
    1b36:	5b de       	rcall	.-842    	; 0x17ee <Endpoint_ClearEndpoints>
			                                                    const uint8_t Type,
			                                                    const uint8_t Direction,
			                                                    const uint16_t Size,
			                                                    const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
    1b38:	80 e0       	ldi	r24, 0x00	; 0
    1b3a:	60 e0       	ldi	r22, 0x00	; 0
    1b3c:	42 e0       	ldi	r20, 0x02	; 2
    1b3e:	44 de       	rcall	.-888    	; 0x17c8 <Endpoint_ConfigureEndpoint_Prv>
		Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
		                           ENDPOINT_DIR_OUT, USB_ControlEndpointSize,
		                           ENDPOINT_BANK_SINGLE);

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
    1b40:	80 91 f0 00 	lds	r24, 0x00F0
    1b44:	88 60       	ori	r24, 0x08	; 8
    1b46:	80 93 f0 00 	sts	0x00F0, r24
		#endif

		EVENT_USB_Device_Reset();
    1b4a:	39 d1       	rcall	.+626    	; 0x1dbe <USB_Event_Stub>
	}
	
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1b4c:	80 91 e1 00 	lds	r24, 0x00E1
    1b50:	82 ff       	sbrs	r24, 2
    1b52:	0a c0       	rjmp	.+20     	; 0x1b68 <__vector_11+0x12c>
    1b54:	80 91 e2 00 	lds	r24, 0x00E2
    1b58:	82 ff       	sbrs	r24, 2
    1b5a:	06 c0       	rjmp	.+12     	; 0x1b68 <__vector_11+0x12c>
	{
		USB_INT_Clear(USB_INT_SOFI);
    1b5c:	80 91 e1 00 	lds	r24, 0x00E1
    1b60:	8b 7f       	andi	r24, 0xFB	; 251
    1b62:	80 93 e1 00 	sts	0x00E1, r24
		
		EVENT_USB_Device_StartOfFrame();
    1b66:	2b d1       	rcall	.+598    	; 0x1dbe <USB_Event_Stub>
		EVENT_USB_UIDChange();

		USB_ResetInterface();
	}
	#endif
}
    1b68:	ff 91       	pop	r31
    1b6a:	ef 91       	pop	r30
    1b6c:	bf 91       	pop	r27
    1b6e:	af 91       	pop	r26
    1b70:	9f 91       	pop	r25
    1b72:	8f 91       	pop	r24
    1b74:	7f 91       	pop	r23
    1b76:	6f 91       	pop	r22
    1b78:	5f 91       	pop	r21
    1b7a:	4f 91       	pop	r20
    1b7c:	3f 91       	pop	r19
    1b7e:	2f 91       	pop	r18
    1b80:	0f 90       	pop	r0
    1b82:	0f be       	out	0x3f, r0	; 63
    1b84:	0f 90       	pop	r0
    1b86:	1f 90       	pop	r1
    1b88:	18 95       	reti

00001b8a <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    1b8a:	1f 93       	push	r17
    1b8c:	df 93       	push	r29
    1b8e:	cf 93       	push	r28
    1b90:	00 d0       	rcall	.+0      	; 0x1b92 <USB_Device_ProcessControlRequest+0x8>
    1b92:	cd b7       	in	r28, 0x3d	; 61
    1b94:	de b7       	in	r29, 0x3e	; 62
    1b96:	e5 e7       	ldi	r30, 0x75	; 117
    1b98:	f1 e0       	ldi	r31, 0x01	; 1
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    1b9a:	80 91 f1 00 	lds	r24, 0x00F1
	bool     RequestHandled = false;
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;
	
	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_Byte();
    1b9e:	81 93       	st	Z+, r24
void USB_Device_ProcessControlRequest(void)
{
	bool     RequestHandled = false;
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;
	
	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    1ba0:	81 e0       	ldi	r24, 0x01	; 1
    1ba2:	ed 37       	cpi	r30, 0x7D	; 125
    1ba4:	f8 07       	cpc	r31, r24
    1ba6:	c9 f7       	brne	.-14     	; 0x1b9a <USB_Device_ProcessControlRequest+0x10>
	  *(RequestHeader++) = Endpoint_Read_Byte();
	  
	uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    1ba8:	80 91 75 01 	lds	r24, 0x0175
	
	switch (USB_ControlRequest.bRequest)
    1bac:	30 91 76 01 	lds	r19, 0x0176
    1bb0:	35 30       	cpi	r19, 0x05	; 5
    1bb2:	09 f4       	brne	.+2      	; 0x1bb6 <USB_Device_ProcessControlRequest+0x2c>
    1bb4:	87 c0       	rjmp	.+270    	; 0x1cc4 <USB_Device_ProcessControlRequest+0x13a>
    1bb6:	36 30       	cpi	r19, 0x06	; 6
    1bb8:	40 f4       	brcc	.+16     	; 0x1bca <USB_Device_ProcessControlRequest+0x40>
    1bba:	31 30       	cpi	r19, 0x01	; 1
    1bbc:	c9 f1       	breq	.+114    	; 0x1c30 <USB_Device_ProcessControlRequest+0xa6>
    1bbe:	31 30       	cpi	r19, 0x01	; 1
    1bc0:	70 f0       	brcs	.+28     	; 0x1bde <USB_Device_ProcessControlRequest+0x54>
    1bc2:	33 30       	cpi	r19, 0x03	; 3
    1bc4:	09 f0       	breq	.+2      	; 0x1bc8 <USB_Device_ProcessControlRequest+0x3e>
    1bc6:	e6 c0       	rjmp	.+460    	; 0x1d94 <USB_Device_ProcessControlRequest+0x20a>
    1bc8:	33 c0       	rjmp	.+102    	; 0x1c30 <USB_Device_ProcessControlRequest+0xa6>
    1bca:	38 30       	cpi	r19, 0x08	; 8
    1bcc:	09 f4       	brne	.+2      	; 0x1bd0 <USB_Device_ProcessControlRequest+0x46>
    1bce:	b8 c0       	rjmp	.+368    	; 0x1d40 <USB_Device_ProcessControlRequest+0x1b6>
    1bd0:	39 30       	cpi	r19, 0x09	; 9
    1bd2:	09 f4       	brne	.+2      	; 0x1bd6 <USB_Device_ProcessControlRequest+0x4c>
    1bd4:	c7 c0       	rjmp	.+398    	; 0x1d64 <USB_Device_ProcessControlRequest+0x1da>
    1bd6:	36 30       	cpi	r19, 0x06	; 6
    1bd8:	09 f0       	breq	.+2      	; 0x1bdc <USB_Device_ProcessControlRequest+0x52>
    1bda:	dc c0       	rjmp	.+440    	; 0x1d94 <USB_Device_ProcessControlRequest+0x20a>
    1bdc:	92 c0       	rjmp	.+292    	; 0x1d02 <USB_Device_ProcessControlRequest+0x178>
	{
		case REQ_GetStatus:
			if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1bde:	80 38       	cpi	r24, 0x80	; 128
    1be0:	21 f0       	breq	.+8      	; 0x1bea <USB_Device_ProcessControlRequest+0x60>
    1be2:	82 38       	cpi	r24, 0x82	; 130
    1be4:	09 f0       	breq	.+2      	; 0x1be8 <USB_Device_ProcessControlRequest+0x5e>
    1be6:	d6 c0       	rjmp	.+428    	; 0x1d94 <USB_Device_ProcessControlRequest+0x20a>
    1be8:	08 c0       	rjmp	.+16     	; 0x1bfa <USB_Device_ProcessControlRequest+0x70>
    1bea:	90 91 71 01 	lds	r25, 0x0171
			if (USB_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
	#endif

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)			
			if (USB_RemoteWakeupEnabled)
    1bee:	80 91 72 01 	lds	r24, 0x0172
    1bf2:	88 23       	and	r24, r24
    1bf4:	99 f0       	breq	.+38     	; 0x1c1c <USB_Device_ProcessControlRequest+0x92>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    1bf6:	92 60       	ori	r25, 0x02	; 2
    1bf8:	11 c0       	rjmp	.+34     	; 0x1c1c <USB_Device_ProcessControlRequest+0x92>
	#endif
			break;
#endif
#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1bfa:	80 91 79 01 	lds	r24, 0x0179
    1bfe:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1c00:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean true if the currently selected endpoint is stalled, false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1c04:	80 91 eb 00 	lds	r24, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    1c08:	90 e0       	ldi	r25, 0x00	; 0
    1c0a:	25 e0       	ldi	r18, 0x05	; 5
    1c0c:	96 95       	lsr	r25
    1c0e:	87 95       	ror	r24
    1c10:	2a 95       	dec	r18
    1c12:	e1 f7       	brne	.-8      	; 0x1c0c <USB_Device_ProcessControlRequest+0x82>
    1c14:	98 2f       	mov	r25, r24
    1c16:	91 70       	andi	r25, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1c18:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1c1c:	80 91 e8 00 	lds	r24, 0x00E8
    1c20:	87 7f       	andi	r24, 0xF7	; 247
    1c22:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Word  Next word to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Word_LE(const uint16_t Word) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Word_LE(const uint16_t Word)
			{
				UEDATX = (Word & 0xFF);
    1c26:	90 93 f1 00 	sts	0x00F1, r25
				UEDATX = (Word >> 8);
    1c2a:	10 92 f1 00 	sts	0x00F1, r1
    1c2e:	93 c0       	rjmp	.+294    	; 0x1d56 <USB_Device_ProcessControlRequest+0x1cc>
			}

			break;
		case REQ_ClearFeature:
		case REQ_SetFeature:
			if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1c30:	88 23       	and	r24, r24
    1c32:	19 f0       	breq	.+6      	; 0x1c3a <USB_Device_ProcessControlRequest+0xb0>
    1c34:	82 30       	cpi	r24, 0x02	; 2
    1c36:	09 f0       	breq	.+2      	; 0x1c3a <USB_Device_ProcessControlRequest+0xb0>
    1c38:	ad c0       	rjmp	.+346    	; 0x1d94 <USB_Device_ProcessControlRequest+0x20a>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    1c3a:	90 e0       	ldi	r25, 0x00	; 0
    1c3c:	8f 71       	andi	r24, 0x1F	; 31
    1c3e:	90 70       	andi	r25, 0x00	; 0
    1c40:	00 97       	sbiw	r24, 0x00	; 0
    1c42:	21 f0       	breq	.+8      	; 0x1c4c <USB_Device_ProcessControlRequest+0xc2>
    1c44:	02 97       	sbiw	r24, 0x02	; 2
    1c46:	09 f0       	breq	.+2      	; 0x1c4a <USB_Device_ProcessControlRequest+0xc0>
    1c48:	a6 c0       	rjmp	.+332    	; 0x1d96 <USB_Device_ProcessControlRequest+0x20c>
    1c4a:	0c c0       	rjmp	.+24     	; 0x1c64 <USB_Device_ProcessControlRequest+0xda>
	{
#if !defined(NO_DEVICE_REMOTE_WAKEUP)			
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_REMOTE_WAKEUP)
    1c4c:	80 91 77 01 	lds	r24, 0x0177
    1c50:	81 30       	cpi	r24, 0x01	; 1
    1c52:	09 f0       	breq	.+2      	; 0x1c56 <USB_Device_ProcessControlRequest+0xcc>
    1c54:	a0 c0       	rjmp	.+320    	; 0x1d96 <USB_Device_ProcessControlRequest+0x20c>
			  USB_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    1c56:	10 92 72 01 	sts	0x0172, r1
    1c5a:	33 30       	cpi	r19, 0x03	; 3
    1c5c:	69 f5       	brne	.+90     	; 0x1cb8 <USB_Device_ProcessControlRequest+0x12e>
    1c5e:	80 93 72 01 	sts	0x0172, r24
    1c62:	2a c0       	rjmp	.+84     	; 0x1cb8 <USB_Device_ProcessControlRequest+0x12e>
			
			break;			
#endif
#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_ENDPOINT_HALT)
    1c64:	80 91 77 01 	lds	r24, 0x0177
    1c68:	88 23       	and	r24, r24
    1c6a:	31 f5       	brne	.+76     	; 0x1cb8 <USB_Device_ProcessControlRequest+0x12e>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1c6c:	20 91 79 01 	lds	r18, 0x0179
    1c70:	27 70       	andi	r18, 0x07	; 7
				
				if (EndpointIndex == ENDPOINT_CONTROLEP)
    1c72:	09 f4       	brne	.+2      	; 0x1c76 <USB_Device_ProcessControlRequest+0xec>
    1c74:	90 c0       	rjmp	.+288    	; 0x1d96 <USB_Device_ProcessControlRequest+0x20c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1c76:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean True if the currently selected endpoint is enabled, false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    1c7a:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (!(Endpoint_IsEnabled()))
    1c7e:	80 ff       	sbrs	r24, 0
    1c80:	8a c0       	rjmp	.+276    	; 0x1d96 <USB_Device_ProcessControlRequest+0x20c>
				  return;

				if (USB_ControlRequest.bRequest == REQ_SetFeature)
    1c82:	33 30       	cpi	r19, 0x03	; 3
    1c84:	21 f4       	brne	.+8      	; 0x1c8e <USB_Device_ProcessControlRequest+0x104>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    1c86:	80 91 eb 00 	lds	r24, 0x00EB
    1c8a:	80 62       	ori	r24, 0x20	; 32
    1c8c:	13 c0       	rjmp	.+38     	; 0x1cb4 <USB_Device_ProcessControlRequest+0x12a>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    1c8e:	80 91 eb 00 	lds	r24, 0x00EB
    1c92:	80 61       	ori	r24, 0x10	; 16
    1c94:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    1c98:	81 e0       	ldi	r24, 0x01	; 1
    1c9a:	90 e0       	ldi	r25, 0x00	; 0
    1c9c:	02 c0       	rjmp	.+4      	; 0x1ca2 <USB_Device_ProcessControlRequest+0x118>
    1c9e:	88 0f       	add	r24, r24
    1ca0:	99 1f       	adc	r25, r25
    1ca2:	2a 95       	dec	r18
    1ca4:	e2 f7       	brpl	.-8      	; 0x1c9e <USB_Device_ProcessControlRequest+0x114>
    1ca6:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    1caa:	10 92 ea 00 	sts	0x00EA, r1
			
			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    1cae:	80 91 eb 00 	lds	r24, 0x00EB
    1cb2:	88 60       	ori	r24, 0x08	; 8
    1cb4:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1cb8:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1cbc:	80 91 e8 00 	lds	r24, 0x00E8
    1cc0:	87 7f       	andi	r24, 0xF7	; 247
    1cc2:	4c c0       	rjmp	.+152    	; 0x1d5c <USB_Device_ProcessControlRequest+0x1d2>
				RequestHandled = true;
			}

			break;
		case REQ_SetAddress:
			if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    1cc4:	88 23       	and	r24, r24
    1cc6:	09 f0       	breq	.+2      	; 0x1cca <USB_Device_ProcessControlRequest+0x140>
    1cc8:	65 c0       	rjmp	.+202    	; 0x1d94 <USB_Device_ProcessControlRequest+0x20a>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    1cca:	10 91 77 01 	lds	r17, 0x0177
    1cce:	80 91 e8 00 	lds	r24, 0x00E8
    1cd2:	87 7f       	andi	r24, 0xF7	; 247
    1cd4:	80 93 e8 00 	sts	0x00E8, r24

	Endpoint_ClearSETUP();
	
	Endpoint_ClearStatusStage();
    1cd8:	9e dd       	rcall	.-1220   	; 0x1816 <Endpoint_ClearStatusStage>
    1cda:	04 c0       	rjmp	.+8      	; 0x1ce4 <USB_Device_ProcessControlRequest+0x15a>
	
	while (!(Endpoint_IsINReady()))
	{
		if (USB_DeviceState == DEVICE_STATE_Unattached)
    1cdc:	8e b3       	in	r24, 0x1e	; 30
    1cde:	88 23       	and	r24, r24
    1ce0:	09 f4       	brne	.+2      	; 0x1ce4 <USB_Device_ProcessControlRequest+0x15a>
    1ce2:	59 c0       	rjmp	.+178    	; 0x1d96 <USB_Device_ProcessControlRequest+0x20c>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI))  ? true : false);
    1ce4:	80 91 e8 00 	lds	r24, 0x00E8

	Endpoint_ClearSETUP();
	
	Endpoint_ClearStatusStage();
	
	while (!(Endpoint_IsINReady()))
    1ce8:	80 ff       	sbrs	r24, 0
    1cea:	f8 cf       	rjmp	.-16     	; 0x1cdc <USB_Device_ProcessControlRequest+0x152>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    1cec:	81 2f       	mov	r24, r17
    1cee:	8f 77       	andi	r24, 0x7F	; 127
	{
		if (USB_DeviceState == DEVICE_STATE_Unattached)
		  return;
	}

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    1cf0:	11 f4       	brne	.+4      	; 0x1cf6 <USB_Device_ProcessControlRequest+0x16c>
    1cf2:	92 e0       	ldi	r25, 0x02	; 2
    1cf4:	01 c0       	rjmp	.+2      	; 0x1cf8 <USB_Device_ProcessControlRequest+0x16e>
    1cf6:	93 e0       	ldi	r25, 0x03	; 3
    1cf8:	9e bb       	out	0x1e, r25	; 30
			#endif
			
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = ((1 << ADDEN) | (Address & 0x7F));
    1cfa:	80 68       	ori	r24, 0x80	; 128
    1cfc:	80 93 e3 00 	sts	0x00E3, r24
    1d00:	4a c0       	rjmp	.+148    	; 0x1d96 <USB_Device_ProcessControlRequest+0x20c>
				RequestHandled = true;
			}

			break;
		case REQ_GetDescriptor:
			if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1d02:	80 58       	subi	r24, 0x80	; 128
    1d04:	82 30       	cpi	r24, 0x02	; 2
    1d06:	08 f0       	brcs	.+2      	; 0x1d0a <USB_Device_ProcessControlRequest+0x180>
    1d08:	45 c0       	rjmp	.+138    	; 0x1d94 <USB_Device_ProcessControlRequest+0x20a>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif
	
	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    1d0a:	80 91 77 01 	lds	r24, 0x0177
    1d0e:	90 91 78 01 	lds	r25, 0x0178
    1d12:	60 91 79 01 	lds	r22, 0x0179
    1d16:	ae 01       	movw	r20, r28
    1d18:	4f 5f       	subi	r20, 0xFF	; 255
    1d1a:	5f 4f       	sbci	r21, 0xFF	; 255
    1d1c:	2c dd       	rcall	.-1448   	; 0x1776 <CALLBACK_USB_GetDescriptor>
    1d1e:	bc 01       	movw	r22, r24
    1d20:	00 97       	sbiw	r24, 0x00	; 0
    1d22:	c9 f1       	breq	.+114    	; 0x1d96 <USB_Device_ProcessControlRequest+0x20c>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1d24:	80 91 e8 00 	lds	r24, 0x00E8
    1d28:	87 7f       	andi	r24, 0xF7	; 247
    1d2a:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);	
    1d2e:	89 81       	ldd	r24, Y+1	; 0x01
    1d30:	9a 81       	ldd	r25, Y+2	; 0x02
    1d32:	90 dd       	rcall	.-1248   	; 0x1854 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1d34:	80 91 e8 00 	lds	r24, 0x00E8
    1d38:	8b 77       	andi	r24, 0x7B	; 123
    1d3a:	80 93 e8 00 	sts	0x00E8, r24
    1d3e:	2b c0       	rjmp	.+86     	; 0x1d96 <USB_Device_ProcessControlRequest+0x20c>
				RequestHandled = true;
			}
			
			break;
		case REQ_GetConfiguration:
			if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    1d40:	80 38       	cpi	r24, 0x80	; 128
    1d42:	41 f5       	brne	.+80     	; 0x1d94 <USB_Device_ProcessControlRequest+0x20a>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1d44:	80 91 e8 00 	lds	r24, 0x00E8
    1d48:	87 7f       	andi	r24, 0xF7	; 247
    1d4a:	80 93 e8 00 	sts	0x00E8, r24

void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_Byte(USB_ConfigurationNumber);
    1d4e:	80 91 73 01 	lds	r24, 0x0173
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    1d52:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1d56:	80 91 e8 00 	lds	r24, 0x00E8
    1d5a:	8e 77       	andi	r24, 0x7E	; 126
    1d5c:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    1d60:	5a dd       	rcall	.-1356   	; 0x1816 <Endpoint_ClearStatusStage>
    1d62:	19 c0       	rjmp	.+50     	; 0x1d96 <USB_Device_ProcessControlRequest+0x20c>
				RequestHandled = true;
			}

			break;
		case REQ_SetConfiguration:
			if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    1d64:	88 23       	and	r24, r24
    1d66:	b1 f4       	brne	.+44     	; 0x1d94 <USB_Device_ProcessControlRequest+0x20a>
}

static void USB_Device_SetConfiguration(void)
{
#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    1d68:	90 91 77 01 	lds	r25, 0x0177
    1d6c:	92 30       	cpi	r25, 0x02	; 2
    1d6e:	98 f4       	brcc	.+38     	; 0x1d96 <USB_Device_ProcessControlRequest+0x20c>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1d70:	80 91 e8 00 	lds	r24, 0x00E8
    1d74:	87 7f       	andi	r24, 0xF7	; 247
    1d76:	80 93 e8 00 	sts	0x00E8, r24
	}
#endif
	
	Endpoint_ClearSETUP();

	USB_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    1d7a:	90 93 73 01 	sts	0x0173, r25

	Endpoint_ClearStatusStage();
    1d7e:	4b dd       	rcall	.-1386   	; 0x1816 <Endpoint_ClearStatusStage>

	USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Addressed;
    1d80:	80 91 73 01 	lds	r24, 0x0173
    1d84:	88 23       	and	r24, r24
    1d86:	11 f4       	brne	.+4      	; 0x1d8c <USB_Device_ProcessControlRequest+0x202>
    1d88:	83 e0       	ldi	r24, 0x03	; 3
    1d8a:	01 c0       	rjmp	.+2      	; 0x1d8e <USB_Device_ProcessControlRequest+0x204>
    1d8c:	84 e0       	ldi	r24, 0x04	; 4
    1d8e:	8e bb       	out	0x1e, r24	; 30

	EVENT_USB_Device_ConfigurationChanged();
    1d90:	16 d0       	rcall	.+44     	; 0x1dbe <USB_Event_Stub>
    1d92:	01 c0       	rjmp	.+2      	; 0x1d96 <USB_Device_ProcessControlRequest+0x20c>

			break;
	}

	if (!(RequestHandled))
	  EVENT_USB_Device_UnhandledControlRequest();
    1d94:	87 da       	rcall	.-2802   	; 0x12a4 <EVENT_USB_Device_UnhandledControlRequest>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1d96:	80 91 e8 00 	lds	r24, 0x00E8
	  
	if (Endpoint_IsSETUPReceived())
    1d9a:	83 ff       	sbrs	r24, 3
    1d9c:	0a c0       	rjmp	.+20     	; 0x1db2 <USB_Device_ProcessControlRequest+0x228>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    1d9e:	80 91 eb 00 	lds	r24, 0x00EB
    1da2:	80 62       	ori	r24, 0x20	; 32
    1da4:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1da8:	80 91 e8 00 	lds	r24, 0x00E8
    1dac:	87 7f       	andi	r24, 0xF7	; 247
    1dae:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();		
	}
}
    1db2:	0f 90       	pop	r0
    1db4:	0f 90       	pop	r0
    1db6:	cf 91       	pop	r28
    1db8:	df 91       	pop	r29
    1dba:	1f 91       	pop	r17
    1dbc:	08 95       	ret

00001dbe <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    1dbe:	08 95       	ret

00001dc0 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    1dc0:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    1dc2:	8e b3       	in	r24, 0x1e	; 30
    1dc4:	88 23       	and	r24, r24
    1dc6:	61 f0       	breq	.+24     	; 0x1de0 <USB_USBTask+0x20>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    1dc8:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1dcc:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1dd0:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();
	
		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    1dd4:	83 ff       	sbrs	r24, 3
    1dd6:	01 c0       	rjmp	.+2      	; 0x1dda <USB_USBTask+0x1a>
		  USB_Device_ProcessControlRequest();
    1dd8:	d8 de       	rcall	.-592    	; 0x1b8a <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    1dda:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1ddc:	10 93 e9 00 	sts	0x00E9, r17
		if (USB_CurrentMode == USB_MODE_DEVICE)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_HOST)
		  USB_HostTask();
	#endif
}
    1de0:	1f 91       	pop	r17
    1de2:	08 95       	ret

00001de4 <_exit>:
    1de4:	f8 94       	cli

00001de6 <__stop_program>:
    1de6:	ff cf       	rjmp	.-2      	; 0x1de6 <__stop_program>
